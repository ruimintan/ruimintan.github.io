<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VSCode常用快捷键-Mac</title>
      <link href="/posts/b6530799.html"/>
      <url>/posts/b6530799.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><blockquote><p>Option + Up 向上移动行<br>Option + Down 向下移动行<br>Option + Shift + Up 向上复制行<br>Option + Shift + Down 向下复制行<br>Command + Shift + K 删除行<br>Command + [ 减少缩进<br>Command + ] 增加缩进<br>Command + / 添加、移除行注释<br>Option + Shift + A 添加、移除块注释</p></blockquote><h1 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h1><blockquote><p>Command + Shift + P / F1 显示命令面板<br>Command + P 快速打开<br>Command + Shift + N 打开新窗口<br>Command + W 关闭窗口</p></blockquote><h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><blockquote><p>Command + X 剪切（未选中文本的情况下，剪切光标所在行）<br>Command + C 复制（未选中文本的情况下，复制光标所在行）<br>Option + Up 向上移动行<br>Option + Down 向下移动行<br>Option + Shift + Up 向上复制行<br>Option + Shift + Down 向下复制行<br>Command + Shift + K 删除行<br>Command + Enter 下一行插入<br>Command + Shift + Enter 上一行插入<br>Command + Shift + \ 跳转到匹配的括号<br>Command + [ 减少缩进<br>Command + ] 增加缩进<br>Home 跳转至行首<br>End 跳转到行尾<br>Command + Up 跳转至文件开头<br>Command + Down 跳转至文件结尾<br>Ctrl + PgUp 按行向上滚动<br>Ctrl + PgDown 按行向下滚动<br>Command + PgUp 按屏向上滚动<br>Command + PgDown 按屏向下滚动<br>Command + Shift + [ 折叠代码块<br>Command + Shift + ] 展开代码块<br>Command + K Command + [ 折叠全部子代码块<br>Command + K Command + ] 展开全部子代码块<br>Command + K Command + 0 折叠全部代码块<br>Command + K Command + J 展开全部代码块<br>Command + K Command + C 添加行注释<br>Command + K Command + U 移除行注释<br>Command + / 添加、移除行注释<br>Option + Shift + A 添加、移除块注释<br>Option + Z 自动换行、取消自动换行</p></blockquote><h1 id="多光标与选择"><a href="#多光标与选择" class="headerlink" title="多光标与选择"></a>多光标与选择</h1><blockquote><p>Option + 点击 插入多个光标<br>Command + Option + Up 向上插入光标<br>Command + Option + Down 向下插入光标<br>Command + U 撤销上一个光标操作<br>Option + Shift + I 在所选行的行尾插入光标<br>Command + I 选中当前行<br>Command + Shift + L 选中所有与当前选中内容相同部分<br>Command + F2 选中所有与当前选中单词相同的单词<br>Command + Ctrl + Shift + Left 折叠选中<br>Command + Ctrl + Shift + Right 展开选中<br>Alt + Shift + 拖动鼠标 选中代码块<br>Command + Shift + Option + Up 列选择 向上<br>Command + Shift + Option + Down 列选择 向下<br>Command + Shift + Option + Left 列选择 向左<br>Command + Shift + Option + Right 列选择 向右<br>Command + Shift + Option + PgUp 列选择 向上翻页<br>Command + Shift + Option + PgDown 列选择 向下翻页</p></blockquote><h1 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h1><blockquote><p>Command + F 查找<br>Command + Option + F 替换<br>Command + G 查找下一个<br>Command + Shift + G 查找上一个<br>Option + Enter 选中所有匹配项<br>Command + D 向下选中相同内容<br>Command + K Command + D 移除前一个向下选中相同内容</p></blockquote><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><blockquote><p>Ctrl + Space 打开建议<br>Command + Shift + Space 参数提示<br>Tab Emmet插件缩写补全<br>Option + Shift + F 格式化<br>Command + K Command + F 格式化选中内容<br>F12 跳转到声明位置<br>Option + F12 查看具体声明内容<br>Command + K F12 分屏查看具体声明内容<br>Command + . 快速修复<br>Shift + F12 显示引用<br>F2 重命名符号<br>Command + Shift + . 替换为上一个值<br>Command + Shift + , 替换为下一个值<br>Command + K Command + X 删除行尾多余空格<br>Command + K M 更改文件语言</p></blockquote><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><blockquote><p>Command + T 显示所有符号<br>Ctrl + G 跳转至某行<br>Command + P 跳转到某个文件<br>Command + Shift + O 跳转到某个符号<br>Command + Shift + M 打开问题面板<br>F8 下一个错误或警告位置<br>Shift + F8 上一个错误或警告位置<br>Ctrl + Shift + Tab 编辑器历史记录<br>Ctrl + - 后退<br>Ctrl + Shift + - 前进<br>Ctrl + Shift + M Tab 切换焦点</p></blockquote><h1 id="编辑器管理"><a href="#编辑器管理" class="headerlink" title="编辑器管理"></a>编辑器管理</h1><blockquote><p>Command + W 关闭编辑器<br>Command + K F 关闭文件夹<br>Command + \ 编辑器分屏<br>Command + 1 切换到第一分组<br>Command + 2 切换到第二分组<br>Command + 3 切换到第三分组<br>Command + K Command + Left 切换到上一分组<br>Command + K Command + Right 切换到下一分组<br>Command + K Command + Shift + Left 左移编辑器<br>Command + K Command + Shift + Right 右移编辑器<br>Command + K Left 激活左侧编辑组<br>Command + K Right 激活右侧编辑组</p></blockquote><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><blockquote><p>Command + N 新建文件<br>Command + O 打开文件<br>Command + S 保存文件<br>Command + Shift + S 另存为<br>Command + Option + S 全部保存<br>Command + W 关闭<br>Command + K Command + W 全部关闭<br>Command + Shift + T 重新打开被关闭的编辑器<br>Command + K Enter 保持打开<br>Ctrl + Tab 打开下一个<br>Ctrl + Shift + Tab 打开上一个<br>Command + K P 复制当前文件路径<br>Command + K R 在资源管理器中查看当前文件<br>Command + K O 新窗口打开当前文件</p></blockquote><h1 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h1><blockquote><p>Command + Ctrl + F 全屏、退出全屏<br>Command + Option + 1 切换编辑器分屏方式（横、竖）<br>Command + + 放大<br>Command + - 缩小<br>Command + B 显示、隐藏侧边栏<br>Command + Shift + E 显示资源管理器 或 切换焦点<br>Command + Shift + F 显示搜索框<br>Ctrl + Shift + G 显示Git面板<br>Command + Shift + D 显示调试面板<br>Command + Shift + X 显示插件面板<br>Command + Shift + H 全局搜索替换<br>Command + Shift + J 显示、隐藏高级搜索<br>Command + Shift + C 打开新终端<br>Command + Shift + U 显示输出面板<br>Command + Shift + V Markdown预览窗口<br>Command + K V 分屏显示 Markdown预览窗口</p></blockquote><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><blockquote><p>F9 设置 或 取消断点<br>F5 开始 或 继续<br>F11 进入<br>Shift + F11 跳出<br>F10 跳过<br>Command + K Command + I 显示悬停信息</p></blockquote><h1 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h1><blockquote><p>Ctrl + 显示终端 Ctrl + Shift + 新建终端<br>Command + Up 向上滚动<br>Command + Down 向下滚动<br>PgUp 向上翻页<br>PgDown 向下翻页<br>Command + Home 滚动到顶部<br>Command + End 滚动到底部</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react脚手架配置代理总结</title>
      <link href="/posts/1b29d888.html"/>
      <url>/posts/1b29d888.html</url>
      
        <content type="html"><![CDATA[<h2 id="方法一：单个代理"><a href="#方法一：单个代理" class="headerlink" title="方法一：单个代理"></a>方法一：单个代理</h2><blockquote><p>在package.json中追加如下配置</p></blockquote><pre class="line-numbers language-json"><code class="language-json"><span class="token property">"proxy"</span><span class="token operator">:</span><span class="token string">"http://localhost:5000"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：</p><ol><li>优点：配置简单，前端请求资源时可以不加任何前缀。</li><li>缺点：不能配置多个代理。</li><li>工作方式：上述方式配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000 （优先匹配前端资源）</li></ol><h2 id="方法二：多个代理"><a href="#方法二：多个代理" class="headerlink" title="方法二：多个代理"></a>方法二：多个代理</h2><ol><li>第一步：创建代理配置文件</li></ol><pre><code>在src下创建配置文件：src/setupProxy.js</code></pre><ol start="2"><li>编写setupProxy.js配置具体代理规则：</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http-proxy-middleware'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span> <span class="token punctuation">{</span>    app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>    <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token string">'/api1'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)</span>        target<span class="token punctuation">:</span> <span class="token string">'http://localhost:5000'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//配置转发目标地址(能返回数据的服务器地址)</span>        changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//控制服务器接收到的请求头中host字段的值</span>        <span class="token comment" spellcheck="true">/*        changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000        changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000        changeOrigin默认值为false，但我们一般将changeOrigin值设为true        */</span>        pathRewrite<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'^/api1'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token string">'/api2'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>         target<span class="token punctuation">:</span> <span class="token string">'http://localhost:5001'</span><span class="token punctuation">,</span>        changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        pathRewrite<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'^/api2'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ol><li>优点：可以配置多个代理，可以灵活的控制请求是否走代理。</li><li>缺点：配置繁琐，前端请求资源时必须加前缀。</li></ol><h2 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h2><p><a href="https://www.bilibili.com/video/BV1wy4y1D7JT?p=65">尚硅谷_react教程_脚手架配置代理_方法1</a><br><a href="https://www.bilibili.com/video/BV1wy4y1D7JT?p=66">尚硅谷_react教程_脚手架配置代理_方法2</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> react脚手架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九种跨域方式实现原理</title>
      <link href="/posts/5dfd073e.html"/>
      <url>/posts/5dfd073e.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前后端数据交互经常会碰到请求跨域，什么是跨域，以及有哪几种跨域方式，这是本文要探讨的内容</p><h2 id="一、什么是跨域？"><a href="#一、什么是跨域？" class="headerlink" title="一、什么是跨域？"></a>一、什么是跨域？</h2><h3 id="1-什么是同源策略及其限制内容？"><a href="#1-什么是同源策略及其限制内容？" class="headerlink" title="1.什么是同源策略及其限制内容？"></a>1.什么是同源策略及其限制内容？</h3><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p><strong>同源策略限制内容有：</strong></p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li><li>DOM 节点</li><li>AJAX 请求发送后，结果被浏览器拦截了</li></ul><p>但是有三个标签是允许跨域加载资源：</p><ul><li>&lt;img src=XXX&gt;</li><li>&lt;link href=XXX&gt;</li><li>&lt;script src=XXX&gt;</li></ul><h3 id="2-常见跨域场景"><a href="#2-常见跨域场景" class="headerlink" title="2.常见跨域场景"></a>2.常见跨域场景</h3><p><strong>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。</strong>不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下所示：</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许跨域</th></tr></thead><tbody><tr><td><a href="http://www.a.com/a.js">http://www.a.com/a.js</a> <br> <a href="http://www.a.com/b.js">http://www.a.com/b.js</a></td><td>同一域名下</td><td>允许</td></tr><tr><td><a href="http://www.a.com/lab/a.js">http://www.a.com/lab/a.js</a> <br> <a href="http://www.a.com/scrept/b.js">http://www.a.com/scrept/b.js</a></td><td>同一域名下不同文件夹</td><td>允许</td></tr><tr><td><a href="http://www.a.com:8000/a.js">http://www.a.com:8000/a.js</a> <br> <a href="http://www.a.com/b.js">http://www.a.com/b.js</a></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js">http://www.a.com/a.js</a> <br> <a href="https://70.32.34.11/b.js">https://70.32.34.11/b.js</a></td><td>域名和域名的对应ip</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js">http://www.a.com/a.js</a> <br> <a href="http://sript.a.com/b.js">http://sript.a.com/b.js</a></td><td>主域相同，子域不同</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js">http://www.a.com/a.js</a> <br> <a href="http://a.com/b.js">http://a.com/b.js</a></td><td>同一域名，不同耳机域名（同上）</td><td>不允许 （cookie这种情况下也不允许）</td></tr><tr><td><a href="http://www.xxx.com/a.js">http://www.xxx.com/a.js</a> <br> <a href="http://www.a.com/b.js">http://www.a.com/b.js</a></td><td>不同域名</td><td>不允许</td></tr></tbody></table><p>特别说明两点：</p><blockquote><p>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。<br>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。</p></blockquote><p>这里你或许有个疑问：<strong>请求跨域了，那么请求到底发出去没有？</strong></p><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</strong>你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p><h2 id="二、跨域解决方案"><a href="#二、跨域解决方案" class="headerlink" title="二、跨域解决方案"></a>二、跨域解决方案</h2><h3 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1.jsonp"></a>1.jsonp</h3><h4 id="1-JSONP原理"><a href="#1-JSONP原理" class="headerlink" title="1) JSONP原理"></a>1) JSONP原理</h4><p>利用 &lt;script&gt; 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</p><h4 id="2-JSONP和AJAX对比"><a href="#2-JSONP和AJAX对比" class="headerlink" title="2) JSONP和AJAX对比"></a>2) JSONP和AJAX对比</h4><p>JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）</p><h4 id="3-JSONP优缺点"><a href="#3-JSONP优缺点" class="headerlink" title="3) JSONP优缺点"></a>3) JSONP优缺点</h4><p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。<br>缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</p><h4 id="4-JSONP的实现流程"><a href="#4-JSONP的实现流程" class="headerlink" title="4) JSONP的实现流程"></a>4) JSONP的实现流程</h4><ul><li>声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</li><li>创建一个 &lt;script&gt; 标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</li><li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是show(‘我不爱你’)。</li><li>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</li></ul><p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// index.html</span><span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">{</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> callback <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>    window<span class="token punctuation">[</span>callback<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>      document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    params <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>params<span class="token punctuation">,</span> callback <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// wd=b&amp;callback=show</span>    <span class="token keyword">let</span> arrs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>      arrs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">?</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>arrs<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  url<span class="token punctuation">:</span> <span class="token string">'http://localhost:3000/say'</span><span class="token punctuation">,</span>  params<span class="token punctuation">:</span> <span class="token punctuation">{</span> wd<span class="token punctuation">:</span> <span class="token string">'Iloveyou'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  callback<span class="token punctuation">:</span> <span class="token string">'show'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这段代码相当于向 ://localhost:3000/say?wd=Iloveyou&amp;callback=show 这个地址请求数据，然后后台返回show(‘我不爱你’)，最后会运行show()这个函数，打印出’我不爱你’</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// server.js</span><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/say'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> <span class="token punctuation">{</span> wd<span class="token punctuation">,</span> callback <span class="token punctuation">}</span> <span class="token operator">=</span> req<span class="token punctuation">.</span>query  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>wd<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Iloveyou</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// show</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callback<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">('我不爱你')`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-jQuery的jsonp形式"><a href="#5-jQuery的jsonp形式" class="headerlink" title="5) jQuery的jsonp形式"></a>5) jQuery的jsonp形式</h4><p>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。</p><pre class="line-numbers language-js"><code class="language-js">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>url<span class="token punctuation">:</span><span class="token string">"http://crossdomain.com/jsonServerResponse"</span><span class="token punctuation">,</span>dataType<span class="token punctuation">:</span><span class="token string">"jsonp"</span><span class="token punctuation">,</span>type<span class="token punctuation">:</span><span class="token string">"get"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//可以省略</span>jsonpCallback<span class="token punctuation">:</span><span class="token string">"show"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//->自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span>jsonp<span class="token punctuation">:</span><span class="token string">"callback"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//->把传递函数名的那个形参callback，可省略</span>success<span class="token punctuation">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-cors"><a href="#2-cors" class="headerlink" title="2.cors"></a>2.cors</h3><p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。<br>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。<br>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。<br>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求。</strong></p><h5 id="1-简单请求"><a href="#1-简单请求" class="headerlink" title="1) 简单请求"></a>1) 简单请求</h5><p>只要同时满足以下两大条件，就属于简单请求<br>条件1：使用下列方法之一：</p><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><p>条件2：Content-Type 的值仅限于下列三者之一：</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p><h4 id="2-复杂请求"><a href="#2-复杂请求" class="headerlink" title="2) 复杂请求"></a>2) 复杂请求</h4><p>不符合以上条件的请求就肯定是复杂请求了。<br>复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。<br>我们用PUT向后台请求时，属于复杂请求，后台需做如下配置：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 允许哪个方法访问我</span>res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Methods'</span><span class="token punctuation">,</span> <span class="token string">'PUT'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 预检的存活时间</span>res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Max-Age'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// OPTIONS请求不做任何处理</span><span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>method <span class="token operator">===</span> <span class="token string">'OPTIONS'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 定义后台返回的内容</span>app<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'/getData'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>headers<span class="token punctuation">)</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'我不爱你'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// index.html</span><span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token string">'name=xiamen'</span> <span class="token comment" spellcheck="true">// cookie不能跨域</span>xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// 前端设置是否带cookie</span>xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'PUT'</span><span class="token punctuation">,</span> <span class="token string">'http://localhost:4000/getData'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'xiamen'</span><span class="token punctuation">)</span>xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>response<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//得到响应头，后台需设置Access-Control-Expose-Headers</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span><span class="token function">getResponseHeader</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//server1.js</span><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token keyword">static</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//server2.js</span><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> whitList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'http://localhost:3000'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">//设置白名单</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> origin <span class="token operator">=</span> req<span class="token punctuation">.</span>headers<span class="token punctuation">.</span>origin  <span class="token keyword">if</span> <span class="token punctuation">(</span>whitList<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置哪个源可以访问我</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span> origin<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 允许携带哪个头访问我</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Headers'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 允许哪个方法访问我</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Methods'</span><span class="token punctuation">,</span> <span class="token string">'PUT'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 允许携带cookie</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Credentials'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 预检的存活时间</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Max-Age'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 允许返回的头</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Expose-Headers'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>method <span class="token operator">===</span> <span class="token string">'OPTIONS'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// OPTIONS请求不做任何处理</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'/getData'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>headers<span class="token punctuation">)</span>  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'jw'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回一个响应头，后台需设置</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'我不爱你'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/getData'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>headers<span class="token punctuation">)</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'我不爱你'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token keyword">static</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">4000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码由//localhost:3000/index.html 向 //localhost:4000/ 跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。</p><h3 id="3-postMessage"><a href="#3-postMessage" class="headerlink" title="3.postMessage"></a>3.postMessage</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</strong></p><blockquote><p>otherWindow.postMessage(message, targetOrigin, [transfer]);</p></blockquote><ul><li>message: 将要发送到其他 window的数据。</li><li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><p>接下来我们看个例子： //localhost:3000/a.html 页面向 //localhost:4000/b.html 传递“我爱你”,然后后者传回”我不爱你”。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// a.html</span>  <span class="token operator">&lt;</span>iframe src<span class="token operator">=</span><span class="token string">"http://localhost:4000/b.html"</span> frameborder<span class="token operator">=</span><span class="token string">"0"</span> id<span class="token operator">=</span><span class="token string">"frame"</span> onload<span class="token operator">=</span><span class="token string">"load()"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>iframe<span class="token operator">></span> <span class="token comment" spellcheck="true">//等它加载完触发一个事件</span>  <span class="token comment" spellcheck="true">//内嵌在http://localhost:3000/a.html</span>    <span class="token operator">&lt;</span>script<span class="token operator">></span>      <span class="token keyword">function</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> frame <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'frame'</span><span class="token punctuation">)</span>        frame<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'我爱你'</span><span class="token punctuation">,</span> <span class="token string">'http://localhost:4000'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//发送数据</span>        window<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//接受返回数据</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//我不爱你</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// b.html</span>  window<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//我爱你</span>    e<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'我不爱你'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>origin<span class="token punctuation">)</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-websocket"><a href="#4-websocket" class="headerlink" title="4.websocket"></a>4.websocket</h3><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。</strong>同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p><p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>我们先来看个例子：本地文件socket.html向localhost:3000发生数据和接受数据</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// socket.html</span><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">let</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">'ws://localhost:3000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    socket<span class="token punctuation">.</span>onopen <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      socket<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'我爱你'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//向服务器发送数据</span>    <span class="token punctuation">}</span>    socket<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//接收服务器返回的数据</span>    <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// server.js</span><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> WebSocket <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ws'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记得安装ws</span><span class="token keyword">let</span> wss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket<span class="token punctuation">.</span>Server</span><span class="token punctuation">(</span><span class="token punctuation">{</span>port<span class="token punctuation">:</span><span class="token number">3000</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>wss<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'connection'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>ws<span class="token punctuation">)</span> <span class="token punctuation">{</span>  ws<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    ws<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'我不爱你'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-Node中间件代理-两次跨域"><a href="#5-Node中间件代理-两次跨域" class="headerlink" title="5. Node中间件代理(两次跨域)"></a>5. Node中间件代理(两次跨域)</h3><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong><br>代理服务器，需要做以下几个步骤：</p><ul><li>接受客户端请求 。</li><li>将请求 转发给服务器。</li><li>拿到服务器 响应 数据。</li><li>将 响应 转发给客户端。</li></ul><p>我们先来看个例子：本地文件index.html文件，通过代理服务器 //localhost:3000 向目标服务器//localhost:4000 请求数据。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// index.html(http://127.0.0.1:5500)</span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>    $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        url<span class="token punctuation">:</span> <span class="token string">'http://localhost:3000'</span><span class="token punctuation">,</span>        type<span class="token punctuation">:</span> <span class="token string">'post'</span><span class="token punctuation">,</span>        data<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'xiamen'</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">'123456'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        contentType<span class="token punctuation">:</span> <span class="token string">'application/json;charset=utf-8'</span><span class="token punctuation">,</span>        success<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// {"title":"fontend","password":"123456"}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        error<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// server1.js 代理服务器(http://localhost:3000)</span><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 第一步：接受客户端请求</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span>  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">:</span> <span class="token string">'*'</span><span class="token punctuation">,</span>    <span class="token string">'Access-Control-Allow-Methods'</span><span class="token punctuation">:</span> <span class="token string">'*'</span><span class="token punctuation">,</span>    <span class="token string">'Access-Control-Allow-Headers'</span><span class="token punctuation">:</span> <span class="token string">'Content-Type'</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 第二步：将请求转发给服务器</span>  <span class="token keyword">const</span> proxyRequest <span class="token operator">=</span> http    <span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>      <span class="token punctuation">{</span>        host<span class="token punctuation">:</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>        port<span class="token punctuation">:</span> <span class="token number">4000</span><span class="token punctuation">,</span>        url<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>        method<span class="token punctuation">:</span> request<span class="token punctuation">.</span>method<span class="token punctuation">,</span>        headers<span class="token punctuation">:</span> request<span class="token punctuation">.</span>headers      <span class="token punctuation">}</span><span class="token punctuation">,</span>      serverResponse <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 第三步：收到服务器的响应</span>        <span class="token keyword">var</span> body <span class="token operator">=</span> <span class="token string">''</span>        serverResponse<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> chunk <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          body <span class="token operator">+</span><span class="token operator">=</span> chunk        <span class="token punctuation">}</span><span class="token punctuation">)</span>        serverResponse<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'The data is '</span> <span class="token operator">+</span> body<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// 第四步：将响应结果转发给浏览器</span>          response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'The proxyServer is running at http://localhost:3000'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// server2.js(http://localhost:4000)</span><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> title<span class="token punctuation">:</span> <span class="token string">'fontend'</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">'123456'</span> <span class="token punctuation">}</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">4000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'The server is running at http://localhost:4000'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出{“title”:”fontend”,”password”:”123456”}</p><h3 id="6-nginx反向代理"><a href="#6-nginx反向代理" class="headerlink" title="6.nginx反向代理"></a>6.nginx反向代理</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。<br>先下载<a href="http://nginx.org/en/download.html">nginx</a>，然后将nginx目录下的nginx.conf修改如下:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// proxy服务器</span>server <span class="token punctuation">{</span>    listen       <span class="token number">81</span><span class="token punctuation">;</span>    server_name  www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span>    location <span class="token operator">/</span> <span class="token punctuation">{</span>        proxy_pass   http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>domain2<span class="token punctuation">.</span>com<span class="token punctuation">:</span><span class="token number">8080</span><span class="token punctuation">;</span>  #反向代理        proxy_cookie_domain www<span class="token punctuation">.</span>domain2<span class="token punctuation">.</span>com www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span> #修改cookie里域名        index  index<span class="token punctuation">.</span>html index<span class="token punctuation">.</span>htm<span class="token punctuation">;</span>        # 当用webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用        add_header Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span>  #当前端只跨域不带cookie时，可为<span class="token operator">*</span>        add_header Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后通过命令行 ==nginx -s reload== 启动nginx</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// index.html</span><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 前端开关：浏览器是否读写cookie</span>xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 访问nginx中的代理服务器</span>xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> <span class="token string">'http://www.domain1.com:81/?user=admin'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// server.js</span><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> qs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'querystring'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'request'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> params <span class="token operator">=</span> qs<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 向前台写cookie</span>    res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>        <span class="token string">'Set-Cookie'</span><span class="token punctuation">:</span> <span class="token string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>   <span class="token comment" spellcheck="true">// HttpOnly:脚本无法读取</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token string">'8080'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Server is running at port 8080...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-window-name-iframe"><a href="#7-window-name-iframe" class="headerlink" title="7.window.name + iframe"></a>7.window.name + iframe</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>其中a.html和b.html是同域的，都是 //localhost:3000; 而c.html是 //localhost:4000</p><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">// a.html(http://localhost:3000/b.html)</span>  <span class="token operator">&lt;</span>iframe src<span class="token operator">=</span><span class="token string">"http://localhost:4000/c.html"</span> frameborder<span class="token operator">=</span><span class="token string">"0"</span> onload<span class="token operator">=</span><span class="token string">"load()"</span> id<span class="token operator">=</span><span class="token string">"iframe"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>iframe<span class="token operator">></span>  <span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token comment" spellcheck="true">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span>    <span class="token keyword">function</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 第1次onload(跨域页)成功后，切换到同域代理页面</span>        <span class="token keyword">let</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iframe<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:3000/b.html'</span><span class="token punctuation">;</span>        first <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>b.html为中间代理页，与a.html同域，内容为空。</p><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">// c.html(http://localhost:4000/c.html)</span>  <span class="token operator">&lt;</span>script<span class="token operator">></span>    window<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'我不爱你'</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="8-location-hash-iframe"><a href="#8-location-hash-iframe" class="headerlink" title="8.location.hash +  iframe"></a>8.location.hash +  iframe</h3><p>实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。</p><p>同样的，a.html和b.html是同域的，都是//localhost:3000;而c.html是//localhost:4000</p><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">// a.html</span>  <span class="token operator">&lt;</span>iframe src<span class="token operator">=</span><span class="token string">"http://localhost:4000/c.html#iloveyou"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>iframe<span class="token operator">></span>  <span class="token operator">&lt;</span>script<span class="token operator">></span>    window<span class="token punctuation">.</span>onhashchange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//检测hash的变化</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">// b.html</span>  <span class="token operator">&lt;</span>script<span class="token operator">></span>    window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash <span class="token operator">=</span> location<span class="token punctuation">.</span>hash     <span class="token comment" spellcheck="true">//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">// c.html</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  iframe<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:3000/b.html#idontloveyou'</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>iframe<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-document-domain-iframe"><a href="#9-document-domain-iframe" class="headerlink" title="9.document.domain + iframe"></a>9.document.domain + iframe</h3><p>该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。<br>只需要给页面添加 document.domain =’test.com’ 表示二级域名都相同就可以实现跨域。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>我们看个例子：页面a.zf1.cn:3000/a.html获取页面b.zf1.cn:3000/b.html中a的值</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// a.html</span><span class="token operator">&lt;</span>body<span class="token operator">></span> helloa  <span class="token operator">&lt;</span>iframe src<span class="token operator">=</span><span class="token string">"http://b.zf1.cn:3000/b.html"</span> frameborder<span class="token operator">=</span><span class="token string">"0"</span> onload<span class="token operator">=</span><span class="token string">"load()"</span> id<span class="token operator">=</span><span class="token string">"frame"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>iframe<span class="token operator">></span>  <span class="token operator">&lt;</span>script<span class="token operator">></span>    document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'zf1.cn'</span>    <span class="token keyword">function</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>frame<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// b.html</span><span class="token operator">&lt;</span>body<span class="token operator">></span>   hellob   <span class="token operator">&lt;</span>script<span class="token operator">></span>     document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'zf1.cn'</span>     <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>   <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul><li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li><li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li><li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li><li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvc与mvvm设计模式</title>
      <link href="/posts/6da92e55.html"/>
      <url>/posts/6da92e55.html</url>
      
        <content type="html"><![CDATA[<p>前沿：了解设计模式对我们而言，具有很大意义，对语言没有限制，它适用于任何语言，是一种变成思想。设计模式最初有四人帮提出，有兴趣的同学可以去了解下，今天给大家主要分析mvc与mvvm设计模式</p><h2 id="一-mvc设计模式："><a href="#一-mvc设计模式：" class="headerlink" title="一.mvc设计模式："></a>一.mvc设计模式：</h2><p>字面理解，mvc就是<strong>model，view，controller</strong>。</p><p>三者又分别是什么呢？</p><ul><li>model有模型的意思，不过这里他代表的数据模型。就是说整个项目运行中担任了数据供给的部分。</li><li>view是视图的意思，这里代表即前端ui视图，就是界面。</li><li>cotroller是控制器的意思，在mvc中起着关联view与model的作用。</li></ul><p>三者如何团结合作完成项目的运行呢？</p><p>先来说说前端工程师等级的区别：<br>我们说前端程序员的等级可以通过分析设计稿看出。<br>较为初级的拿到设计稿。第一眼看到的往往是视图界面，设计稿上有哪些功能，颜色分类，层级等。<br>中级的前端开发工程师拿到设计稿后，第一眼往往会看设计稿有那些功能，轮播图，分页，三级联动等等。<br>而高级开发工程师在看到设计稿后，往往会思考，该页面中有哪些模块，那些数据分类。如广告，商品列表等</p><p>一个前端项目的完成往往是从建模开始，又牵扯到一个问题，什么是建模?<br>建模说白了，就是对ui视图即界面的抽象。抽象这一过程就是将页面中的数据分类并分离出来。其实掌握了 这一点，在开发的过程中，往往在没有后端数据的 情况下，可以精确的mock出准备的数据。</p><p>回到三者的团结运行，view视图还原成功后，静态页面就算是完成了，要实现动态，我们就需要从model（数据模型）中拿到我们需要的数据。在这个过程中，view会去controller中查找属性和方法。属性从model中拿到数据后反馈给view，最终完成数据的渲染并展示在用户眼前。</p><p>值得我们注意的是，mvc的流程中 ，controller其实是<strong>被动</strong>的一个过程，被动接受view发起的请求，然后进行相应的处理。</p><h2 id="二-mvvm设计模式"><a href="#二-mvvm设计模式" class="headerlink" title="二.mvvm设计模式"></a>二.mvvm设计模式</h2><p>model（数据模型），view（视图），viewmodel（视图模型）</p><p>大家可以看到，里面是没有controller了，但是他将viewmodel代替了controller。<br>在运行过程中起了view和 model的链接桥梁，但是又有一点区别与mvc的是，mvc中被动接受view请求的controller在这里，viewmodel给他做了升级，不再是被动接受，而是不断监听view，当有新的需求时，就去链接model拿去数据，然后返回给页面，很好的将view和model做了分离，使view和viewmodel可以独立完成开发。</p><p>缺点：不断的监听页面，性能消耗很大！</p><h2 id="三-mvc和mvvm的区别"><a href="#三-mvc和mvvm的区别" class="headerlink" title="三.mvc和mvvm的区别"></a>三.mvc和mvvm的区别</h2><ol><li><p>mvc中controller是被动接受请求，而mvvm中作为控制器这一环节的是主动地。</p></li><li><p>mvc中view可以直接访问model，因此view中必然包含了业务逻辑，并没有实现view和model的分离，而mvvm主要是通过数据的双向绑定机制，在js中实现业务逻辑，进行view和model的关联，因此mvvm真正意义上实现了view和model的分离。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入高阶函数应用之柯里化</title>
      <link href="/posts/c9f18867.html"/>
      <url>/posts/c9f18867.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、高阶函数"><a href="#一、高阶函数" class="headerlink" title="一、高阶函数"></a>一、高阶函数</h2><p>高阶函数英文叫 Higher-order function，它的定义很简单，就是至少满足下列一个条件的函数：</p><ul><li>接受一个或多个函数作为输入</li><li>输出一个函数</li></ul><p>也就是说高阶函数是对其他函数进行操作的函数，可以将它们作为参数传递，或者是返回它们。<br>简单来说，高阶函数是一个接收函数作为参数传递或者将函数作为返回值输出的函数。</p><h2 id="二、柯里化"><a href="#二、柯里化" class="headerlink" title="二、柯里化"></a>二、柯里化</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>函数柯里化又叫部分求值，维基百科中对柯里化 (Currying) 的定义为：</p><blockquote><p>在数学和计算机科学中，柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><p>通俗来说就是只传递给函数一部分参数来调用它，让它返回一个新函数去处理剩下的参数。<br>使用一个简单的例子来介绍下，最常用的就是 add 函数了。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> args<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 传入多个参数，执行 add 函数</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 3</span><span class="token comment" spellcheck="true">// 假设我们实现了一个 currying 函数，支持一次传入一个参数</span><span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token function">currying</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 封装第一个参数，方便重用</span><span class="token keyword">let</span> addCurryOne <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">addCurryOne</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 3</span><span class="token function">addCurryOne</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><h4 id="1、延迟计算"><a href="#1、延迟计算" class="headerlink" title="1、延迟计算"></a>1、延迟计算</h4><p>我们看下面的部分求和例子，很好的说明了延迟计算这个情况。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> args<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 简化写法</span><span class="token keyword">function</span> <span class="token function">currying</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">result</span><span class="token punctuation">(</span><span class="token operator">...</span>rest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rest<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>rest<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token function">currying</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 未真正求值</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 未真正求值</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 输出 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码理解起来很容易，就是「用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数」。上面的 currying 函数是一种简化写法，判断传入的参数长度是否为 0，若为 0 执行函数，否则收集参数。</p><p><strong>另一种常见的应用是 bind 函数</strong>，我们看下 bind 的使用。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'muyiy'</span><span class="token punctuation">}</span><span class="token keyword">const</span> fun <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里 bind 用来改变函数执行时候的上下文，但是函数本身并不执行，所以本质上是延迟计算，这一点和 call / apply 直接执行有所不同。</p><p>我们看下 bind 模拟实现，其本身就是一种柯里化，我们在最后的实现部分会发现，bind 的模拟实现和柯理化函数的实现，其核心代码都是一致的。</p><p>以下实现方案是简化版实现</p><pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>bind <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第 1 个参数是指定的 this，截取保存第 1 个之后的参数</span>        <span class="token comment" spellcheck="true">// arr.slice(begin); 即 [begin, end]</span>    <span class="token keyword">var</span> args <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 此时的 arguments 是指 bind 返回的函数调用时接收的参数</span>        <span class="token comment" spellcheck="true">// 即 return function 的参数，和上面那个不同</span>          <span class="token comment" spellcheck="true">// 类数组转成数组</span>        <span class="token keyword">var</span> bindArgs <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 执行函数</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>bindArgs<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、动态创建函数"><a href="#2、动态创建函数" class="headerlink" title="2、动态创建函数"></a>2、动态创建函数</h4><p>有一种典型的应用情景是这样的，每次调用函数都需要进行一次判断，但其实第一次判断计算之后，后续调用并不需要再次判断，这种情况下就非常适合使用柯里化方案来处理。即第一次判断之后，动态创建一个新函数用于处理后续传入的参数，并返回这个新函数。当然也可以使用惰性函数来处理，本例最后一个方案会有所介绍。</p><p>我们看下面的这个例子，在 DOM 中添加事件时需要兼容现代浏览器和 IE 浏览器（IE &lt; 9），方法就是对浏览器环境进行判断，看浏览器是否支持，简化写法如下。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 简化写法</span><span class="token keyword">function</span> addEvent <span class="token punctuation">(</span>type<span class="token punctuation">,</span> el<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> capture <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>        el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> capture<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>attachEvent<span class="token punctuation">)</span><span class="token punctuation">{</span>        el<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">'on'</span> <span class="token operator">+</span> type<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这种写法有一个问题，就是每次添加事件都会调用做一次判断，那么有没有什么办法只判断一次呢，可以利用闭包和立即调用函数表达式（IIFE）来处理。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> addEvent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>type<span class="token punctuation">,</span> el<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> capture<span class="token punctuation">)</span> <span class="token punctuation">{</span>            el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> capture<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>attachEvent<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>type<span class="token punctuation">,</span> el<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            el<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">'on'</span> <span class="token operator">+</span> type<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这种实现方案就是一种典型的柯里化应用，在第一次的 if…else if… 判断之后完成部分计算，动态创建新的函数用于处理后续传入的参数，这样做的好处就是之后调用就不需要再次计算了。</p><p><strong>当然可以使用惰性函数来实现这一功能</strong>，原理很简单，就是重写函数。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> addEvent <span class="token punctuation">(</span>type<span class="token punctuation">,</span> el<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> capture <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 重写函数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>        addEvent <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>type<span class="token punctuation">,</span> el<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> capture<span class="token punctuation">)</span> <span class="token punctuation">{</span>            el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> capture<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>attachEvent<span class="token punctuation">)</span><span class="token punctuation">{</span>        addEvent <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>type<span class="token punctuation">,</span> el<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            el<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">'on'</span> <span class="token operator">+</span> type<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 执行函数，有循环爆栈风险</span>      <span class="token function">addEvent</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> el<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> capture<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一次调用 addEvent 函数后，会进行一次环境判断，在这之后 addEvent 函数被重写，所以下次调用时就不会再次判断环境，可以说很完美了。</p><h4 id="3、参数复用"><a href="#3、参数复用" class="headerlink" title="3、参数复用"></a>3、参数复用</h4><p>我们知道调用 toString() 可以获取每个对象的类型，但是不同对象的 toString() 有不同的实现，所以需要通过 Object.prototype.toString() 来获取 Object 上的实现，同时以 call() / apply() 的形式来调用，并传递要检查的对象作为第一个参数，例如下面这个例子。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Array]'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">isNumber</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Number]'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">isString</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object String]'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Test</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token function">isNumber</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token function">isString</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是上面方案有一个问题，那就是每种类型都需要定义一个方法，这里我们可以使用 bind 来扩展，优点是可以直接使用改造后的 toStr。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> toStr <span class="token operator">=</span> Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>call<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 改造前</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "1,2,3"</span><span class="token string">'123'</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "123"</span><span class="token number">123</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SyntaxError: Invalid or unexpected token</span><span class="token function">Object</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "123"</span><span class="token comment" spellcheck="true">// 改造后</span><span class="token function">toStr</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// "[object Array]"</span><span class="token function">toStr</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// "[object String]"</span><span class="token function">toStr</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// "[object Number]"</span><span class="token function">toStr</span><span class="token punctuation">(</span><span class="token function">Object</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "[object Number]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面例子首先使用 Function.prototype.call 函数指定一个 this 值，然后 .bind 返回一个新的函数，始终将 Object.prototype.toString 设置为传入参数，其实等价于 Object.prototype.toString.call() 。</p><h2 id="三、实现-currying-函数"><a href="#三、实现-currying-函数" class="headerlink" title="三、实现 currying 函数"></a>三、实现 currying 函数</h2><p>我们可以理解所谓的柯里化函数，就是封装「一系列的处理步骤」，通过闭包将参数集中起来计算，最后再把需要处理的参数传进去。那如何实现 currying 函数呢？</p><p>实现原理就是「用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数」。上面延迟计算部分已经实现了一个简化版的 currying 函数。</p><p>下面我们来实现一个更加健壮的的 currying 函数。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">currying</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>  length <span class="token operator">=</span> length <span class="token operator">||</span> fn<span class="token punctuation">.</span>length<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 注释 1</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 注释 2</span>    <span class="token keyword">return</span> args<span class="token punctuation">.</span>length <span class="token operator">>=</span> length    <span class="token comment" spellcheck="true">// 注释 3</span>        <span class="token operator">?</span> fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 注释 4</span>      <span class="token punctuation">:</span> <span class="token function">currying</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span> length <span class="token operator">-</span> args<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 注释 5</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Test</span><span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">currying</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ["a", "b", "c"]</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ["a", "b", "c"]</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ["a", "b", "c"]</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ["a", "b", "c"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>注释 1：第一次调用获取函数 fn 参数的长度，后续调用获取 fn 剩余参数的长度</p></li><li><p>注释 2：currying 包裹之后返回一个新函数，接收参数为 …args</p></li><li><p>注释 3：新函数接收的参数长度是否大于等于 fn 剩余参数需要接收的长度</p></li><li><p>注释 4：满足要求，执行 fn 函数，传入新函数的参数</p></li><li><p>注释 5：不满足要求，递归 currying 函数，新的 fn 为 bind 返回的新函数（bind 绑定了 …args 参数，未执行），新的 length 为 fn 剩余参数的长度</p></li></ul><p>上面使用的是 ES5 和 ES6 的混合语法，那我不想使用 call/apply/bind 这些方法呢，自然是可以的，看下面的 ES6 极简写法，更加简洁也更加易懂。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 参考自 segmentfault 的@大笑平 </span><span class="token keyword">const</span> currying <span class="token operator">=</span> fn <span class="token operator">=</span><span class="token operator">></span>    judge <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>        args<span class="token punctuation">.</span>length <span class="token operator">>=</span> fn<span class="token punctuation">.</span>length            <span class="token operator">?</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>            <span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">judge</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Test</span><span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">currying</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ["a", "b", "c"]</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ["a", "b", "c"]</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ["a", "b", "c"]</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ["a", "b", "c"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你还无法理解，看完下面例子你就更加容易理解了，要求实现一个 add 方法，需要满足如下预期。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 6</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 6</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 6</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到，计算结果就是所有参数的和，如果我们分两次调用时 add(1)(2)，可以写出如下代码。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>add 方法第一次调用后返回一个新函数，通过闭包保存之前的参数，第二次调用时满足参数长度要求然后执行函数。</p><p>如果分三次调用时 add(1)(2)(3)，可以写出如下代码。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前面两次调用每次返回一个新函数，第三次调用后满足参数长度要求然后执行函数。</p><p>这时候我们再来看 currying 实现函数，其实就是判断当前参数长度够不够，参数够了就立马执行，不够就返回一个新函数，这个新函数并不执行，并且通过 bind 或者闭包保存之前传入的参数。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 注释同上</span><span class="token keyword">function</span> <span class="token function">currying</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>  length <span class="token operator">=</span> length <span class="token operator">||</span> fn<span class="token punctuation">.</span>length<span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> args<span class="token punctuation">.</span>length <span class="token operator">>=</span> length            <span class="token operator">?</span> fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>                  <span class="token punctuation">:</span> <span class="token function">currying</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span> length <span class="token operator">-</span> args<span class="token punctuation">.</span>length<span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、扩展：函数参数-length"><a href="#四、扩展：函数参数-length" class="headerlink" title="四、扩展：函数参数 length"></a>四、扩展：函数参数 length</h2><p>函数 currying 的实现中，使用了 fn.length 来表示函数参数的个数，那 fn.length 表示函数的所有参数个数吗？并不是。</p><p>函数的 length 属性获取的是形参的个数，但是形参的数量不包括剩余参数个数，而且仅包括第一个具有默认值之前的参数个数，看下面的例子。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2 </span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 </span><span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0 </span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0</span><span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以在柯里化的场景中，不建议使用 ES6 的函数参数默认值。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">currying</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// [1, undefined, undefined]</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Uncaught TypeError: fn(...) is not a function</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们期望函数 fn 输出 [1, 2, 3]，但是实际上调用柯里化函数时 ((a = 1, b, c) =&gt; {}).length === 0，所以调用 fn() 时就已经执行并输出了 [1, undefined, undefined]，而不是理想中的返回闭包函数，所以后续调用 fn()(2)(3) 将会报错。</p><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>我们通过定义认识了什么是柯里化函数，并且介绍了三种实际的应用场景：延迟计算、动态创建函数、参数复用，然后实现了强大的通用化 currying 函数，不过更像是柯里化 (currying) 和偏函数 (partial application) 的综合应用，并且在最后介绍了函数的 length，算是意外之喜。</p><ul><li>定义：柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术</li><li>实际应用<ul><li>延迟计算：部分求和、bind 函数</li><li>动态创建函数：添加监听 addEvent、惰性函数</li><li>参数复用：Function.prototype.call.bind(Object.prototype.toString)</li></ul></li><li>实现 currying 函数：用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数</li><li>函数参数 length：获取的是形参的个数，但是形参的数量不包括剩余参数个数，而且仅包括第一个具有默认值之前的参数个数</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JavaScript执行上下文和执行栈</title>
      <link href="/posts/b4ff910a.html"/>
      <url>/posts/b4ff910a.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你是一名 JavaScript 开发者，或者想要成为一名 JavaScript 开发者，那么你必须知道 JavaScript 程序内部的执行机制。执行上下文和执行栈是JavaScript中关键概念之一，是JavaScript难点之一。 理解执行上下文和执行栈同样有助于理解其他的 JavaScript 概念如提升机制、作用域和闭包等。本文尽可能用通俗易懂的方式来介绍这些概念。</p><h2 id="一、执行上下文（Execution-Context）"><a href="#一、执行上下文（Execution-Context）" class="headerlink" title="一、执行上下文（Execution Context）"></a>一、执行上下文（Execution Context）</h2><h3 id="1-什么是执行上下文"><a href="#1-什么是执行上下文" class="headerlink" title="1.什么是执行上下文"></a>1.什么是执行上下文</h3><p>简而言之，执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行</p><h3 id="2-执行上下文的类型"><a href="#2-执行上下文的类型" class="headerlink" title="2.执行上下文的类型"></a>2.执行上下文的类型</h3><p>执行上下文总共有三种类型：</p><ul><li><p><strong>全局执行上下文</strong>： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：</p><ul><li>创建一个全局对象，在浏览器中这个全局对象就是 window 对象。</li><li>将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。</li></ul></li><li><p><strong>函数执行上下文</strong>： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。</p></li><li><p><strong>Eval 函数执行上下文</strong>： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。</p></li></ul><h2 id="二、执行上下文的生命周期"><a href="#二、执行上下文的生命周期" class="headerlink" title="二、执行上下文的生命周期"></a>二、执行上下文的生命周期</h2><p>执行上下文的生命周期包括三个阶段：<strong>创建阶段→执行阶段→回收阶段</strong>，本文重点介绍创建阶段。</p><h3 id="1-创建阶段"><a href="#1-创建阶段" class="headerlink" title="1.创建阶段"></a>1.创建阶段</h3><p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p><ul><li>创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。下文会详细说明。</li><li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li><li>确定this指向：包括多种情况，下文会详细说明</li></ul><p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p><p>另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出this arguments和函数的参数。</p><h3 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2.执行阶段"></a>2.执行阶段</h3><p>执行变量赋值、代码执行</p><h3 id="3-回收阶段"><a href="#3-回收阶段" class="headerlink" title="3.回收阶段"></a>3.回收阶段</h3><p>执行上下文出栈等待虚拟机回收执行上下文</p><h2 id="三、变量提升和this指向的细节"><a href="#三、变量提升和this指向的细节" class="headerlink" title="三、变量提升和this指向的细节"></a>三、变量提升和this指向的细节</h2><h3 id="1-变量声明提升"><a href="#1-变量声明提升" class="headerlink" title="1.变量声明提升"></a>1.变量声明提升</h3><p>大部分编程语言都是先声明变量再使用，但在JS中，事情有些不一样：</p><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// undefined</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述代码正常输出undefined而不是报错Uncaught ReferenceError: a is not defined,这是因为声明提升（hoisting），相当于如下代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//声明 默认值是undefined “准备工作”</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//赋值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-函数声明提升"><a href="#2-函数声明提升" class="headerlink" title="2.函数声明提升"></a>2.函数声明提升</h3><p>我们都知道，创建一个函数的方法有两种，一种是通过函数声明function foo(){}<br>另一种是通过函数表达式var foo = function(){} ,那这两种在函数提升有什么区别呢？</p><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// function f1(){}</span><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 函数声明</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// undefined</span><span class="token keyword">var</span> f2 <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 函数表达式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们通过一个例子来说明这个问题：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Uncaught TypeError "foo is not a function"</span>    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "this will run!"</span>    <span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// function expression assigned to local variable 'foo'</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"this won't run!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// function declaration, given the name 'bar'</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"this will run!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，foo()调用的时候报错了，而bar能够正常调用。</p><p>我们前面说过变量和函数都会上升，遇到函数表达式 var foo = function(){}时，首先会将var foo上升到函数体顶部，然而此时的foo的值为undefined,所以执行foo()报错。</p><p>而对于函数bar(), 则是提升了整个函数，所以bar()才能够顺利执行。</p><p>有个细节必须注意：<strong>当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值</strong>。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出：function a(){ alert('我是函数') }</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'我是函数'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'我是变量'</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出：'我是变量'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>function声明的优先级比var声明高，也就意味着当两个同名变量同时被function和var声明时，function声明会覆盖var声明</p><p>这代码等效于：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'我是函数'</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">var</span> a<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//hoisting</span><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出：function a(){ alert('我是函数') }</span>a <span class="token operator">=</span> <span class="token string">'我是变量'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//赋值</span><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出：'我是变量'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们看个复杂点的例子：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1. 形参 arg 是 "hi"</span>    <span class="token comment" spellcheck="true">// 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 function</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">var</span> arg <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3.var arg 变量声明被忽略， arg = 'hello'被执行</span>    <span class="token keyword">function</span> <span class="token function">arg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 输出：function arg(){    console.log('hello world')     }hello */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为当函数执行的时候,首先会形成一个新的私有的作用域，然后依次按照如下的步骤执行：</p><ul><li>如果有形参，先给形参赋值</li><li>进行私有作用域中的预解释，函数声明优先级比变量声明高，最后后者会被前者所覆盖，但是可以重新赋值</li><li>私有作用域中的代码从上到下执行</li></ul><h3 id="3-确定this的指向"><a href="#3-确定this的指向" class="headerlink" title="3.确定this的指向"></a>3.确定this的指向</h3><p>先搞明白一个很重要的概念 —— <strong>this的值是在执行的时候才能确认，定义的时候不能确认！</strong> 为什么呢 —— 因为this是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 情况1</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//1</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 情况2</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>fn<span class="token punctuation">:</span>fn<span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//this->obj</span><span class="token comment" spellcheck="true">// 情况3</span><span class="token keyword">function</span> <span class="token function">CreateJsPerson</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//this是当前类的一个实例p1</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//=>p1.name=name</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//=>p1.age=age</span><span class="token punctuation">}</span><span class="token keyword">var</span> p1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">CreateJsPerson</span><span class="token punctuation">(</span><span class="token string">"尹华芝"</span><span class="token punctuation">,</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 情况4</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">+</span> c <span class="token operator">+</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>add<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 + 3 + 5 + 7 = 16</span>add<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 + 3 + 10 + 20 = 34</span><span class="token comment" spellcheck="true">// 情况5</span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"btn1"</span><span class="token operator">></span>箭头函数<span class="token keyword">this</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>       <span class="token keyword">let</span> btn1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>        name<span class="token punctuation">:</span> <span class="token string">'kobe'</span><span class="token punctuation">,</span>        age<span class="token punctuation">:</span> <span class="token number">39</span><span class="token punctuation">,</span>        getName<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            btn1<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//obj</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    obj<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们逐一解释上面几种情况</p><ul><li>对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window</li><li>对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象</li><li>在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例</li><li>call、apply和bind：this 是第一个参数</li><li>箭头函数this指向:箭头函数没有自己的this，看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/images/foo_this.jpg"></p><h2 id="四、执行上下文栈（Execution-Context-Stack）"><a href="#四、执行上下文栈（Execution-Context-Stack）" class="headerlink" title="四、执行上下文栈（Execution Context Stack）"></a>四、执行上下文栈（Execution Context Stack）</h2><p>函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？</p><p>JavaScript 引擎创建了执行上下文栈来管理执行上下文。<strong>可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。</p><p>从上面的流程图，我们需要记住几个关键点：</p><ul><li>JavaScript执行在单线程上，所有的代码都是排队执行。</li><li>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</li><li>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。</li><li>浏览器的JS执行引擎总是访问栈顶的执行上下文。</li><li>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</li></ul><p>我们再来看个例子：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> color <span class="token operator">=</span> <span class="token string">'blue'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">changeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> anotherColor <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">swapColors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> tempColor <span class="token operator">=</span> anotherColor<span class="token punctuation">;</span>        anotherColor <span class="token operator">=</span> color<span class="token punctuation">;</span>        color <span class="token operator">=</span> tempColor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">swapColors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">changeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码运行按照如下步骤：</p><ul><li>当上述代码在浏览器中加载时，JavaScript 引擎会创建一个全局执行上下文并且将它推入当前的执行栈</li><li>调用 changeColor函数时，此时changeColor函数内部代码还未执行，js执行引擎立即创建一个changeColor的执行上下文（简称EC），然后把这执行上下文压入到执行栈（简称ECStack）中。</li><li>执行changeColor函数过程中，调用swapColors函数，同样地，swapColors函数执行之前也创建了一个swapColors的执行上下文，并压入到执行栈中。</li><li>swapColors函数执行完成，swapColors函数的执行上下文出栈，并且被销毁。</li><li>changeColor函数执行完成，changeColor函数的执行上下文出栈，并且被销毁。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JavaScript作用域和作用域链</title>
      <link href="/posts/b2f97a16.html"/>
      <url>/posts/b2f97a16.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript中有一个被称为作用域(Scope)的特性。虽然对于许多新手开发者来说，作用域的概念并不是很容易理解，本文我会尽我所能用最简单的方式来解释作用域和作用域链，希望大家有所收获！</p><h2 id="一、作用域-Scope"><a href="#一、作用域-Scope" class="headerlink" title="一、作用域(Scope)"></a>一、作用域(Scope)</h2><h3 id="1-什么是作用域"><a href="#1-什么是作用域" class="headerlink" title="1.什么是作用域"></a>1.什么是作用域</h3><p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。可能这两句话并不好理解，我们先来看个例子：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">outFun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> inVariable <span class="token operator">=</span> <span class="token string">"内层变量2"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">outFun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//要先执行这个函数，否则根本不知道里面是啥</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>inVariable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Uncaught ReferenceError: inVariable is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的例子可以体会到作用域的概念，变量inVariable在全局作用域没有声明，所以在全局作用域下取值会报错。我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</strong>。</p><p><strong>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域</strong>。ES6的到来，为我们提供了‘块级作用域’,可通过新增命令let和const来体现。</p><h3 id="2-全局作用域和函数作用域"><a href="#2-全局作用域和函数作用域" class="headerlink" title="2.全局作用域和函数作用域"></a>2.全局作用域和函数作用域</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p><ul><li>最外层函数 和在最外层函数外面定义的变量拥有全局作用域</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> outVariable <span class="token operator">=</span> <span class="token string">"我是最外层变量"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//最外层变量</span><span class="token keyword">function</span> <span class="token function">outFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//最外层函数</span>    <span class="token keyword">var</span> inVariable <span class="token operator">=</span> <span class="token string">"内层变量"</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">innerFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//内层函数</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>inVariable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">innerFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outVariable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//我是最外层变量</span><span class="token function">outFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//内层变量</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>inVariable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//inVariable is not defined</span><span class="token function">innerFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//innerFun is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">outFun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    variable <span class="token operator">=</span> <span class="token string">"未定义直接赋值的变量"</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> inVariable2 <span class="token operator">=</span> <span class="token string">"内层变量2"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">outFun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//要先执行这个函数，否则根本不知道里面是啥</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//未定义直接赋值的变量</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>inVariable2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//inVariable2 is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>所有window对象的属性拥有全局作用域</li></ul><p>一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。</p><p>全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 张三写的代码中</span><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 李四写的代码中</span><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在(function(){….})()中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。</p><p>函数作用域,是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> blogName<span class="token operator">=</span><span class="token string">"浪里行舟"</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">innerSay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>blogName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">innerSay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">alert</span><span class="token punctuation">(</span>blogName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//脚本错误</span><span class="token function">innerSay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//脚本错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行</strong>。我们看个例子，用泡泡来比喻作用域可能好理解一点：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/images/action_scope.jpg"></p><p>最后输出的结果为 2, 4, 12</p><ul><li>泡泡1是全局作用域，有标识符foo；</li><li>泡泡2是作用域foo，有标识符a,bar,b；</li><li>泡泡3是作用域bar，仅有标识符c。</li></ul><p>值得注意的是：<strong>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 'if' 条件语句块不会创建一个新的作用域</span>    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'Hammad'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// name 依然在全局作用域中</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// logs 'Hammad'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JS 的初学者经常需要花点时间才能习惯变量提升，而如果不理解这种特有行为，就可能导致<br>bug 。正因为如此， ES6 引入了块级作用域，让变量的生命周期更加可控。</p><h3 id="3-块级作用域"><a href="#3-块级作用域" class="headerlink" title="3.块级作用域"></a>3.块级作用域</h3><p>块级作用域可通过新增命令let和const声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个代码块（由一对花括号包裹）内部</li></ol><p>let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p><ul><li>声明变量不会提升到代码块顶部</li></ul><p>let/const 声明并不会被提升到当前代码块的顶部，因此你需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getValue</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">"blue"</span><span class="token punctuation">;</span><span class="token keyword">return</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// value 在此处不可用</span><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// value 在此处不可用</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>禁止重复声明</li></ul><p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致抛出错误。例如：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Uncaught SyntaxError: Identifier 'count' has already been declared</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在本例中， count 变量被声明了两次：一次使用 var ，另一次使用 let 。因为 let 不能在同一作用域内重复声明一个已有标识符，此处的 let 声明就会抛出错误。但如果在嵌套的作用域内使用 let 声明一个同名的新变量，则不会抛出错误。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 不会抛出错误</span><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 其他代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>循环中的绑定块作用域的妙用</li></ul><p>开发者可能最希望实现for循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，例如：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ReferenceError: i is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。</p><p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p><p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// abc</span><span class="token comment" spellcheck="true">// abc</span><span class="token comment" spellcheck="true">// abc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p><h2 id="二、作用域链"><a href="#二、作用域链" class="headerlink" title="二、作用域链"></a>二、作用域链</h2><h3 id="1-什么是自由变量"><a href="#1-什么是自由变量" class="headerlink" title="1.什么是自由变量"></a>1.什么是自由变量</h3><p>首先认识一下什么叫做 <strong>自由变量</strong> 。如下代码中，console.log(a)要得到a变量，但是在当前的作用域中没有定义a（可对比一下b）。当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找（注意：这种说法并不严谨，下文会重点解释）。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">200</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这里的a在这里就是一个自由变量</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-什么是作用域链"><a href="#2-什么是作用域链" class="headerlink" title="2.什么是作用域链"></a>2.什么是作用域链</h3><p>如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">function</span> <span class="token function">F1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">200</span>    <span class="token keyword">function</span> <span class="token function">F2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">300</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 自由变量，顺作用域链向父作用域找</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 自由变量，顺作用域链向父作用域找</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 本作用域的变量</span>    <span class="token punctuation">}</span>    <span class="token function">F2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">F1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-关于自由变量的取值"><a href="#3-关于自由变量的取值" class="headerlink" title="3.关于自由变量的取值"></a>3.关于自由变量的取值</h2><p>关于自由变量的值，上文提到要到父作用域中取，其实有时候这种解释会产生歧义。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">20</span>  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//10，而不是20</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">show</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取，<strong>无论fn函数将在哪里调用</strong>。</p><p>所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切:<strong>要到创建这个函数的那个域”</strong>。<br><strong>作用域中取值,这里强调的是“创建”，而不是“调用”</strong>，切记切记——其实这就是所谓的”静态作用域”</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">20</span>  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//30</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> bar<span class="token punctuation">}</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  b <span class="token operator">=</span> <span class="token number">200</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//bar()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了,所以最后的结果是30</p><h2 id="三、作用域与执行上下文"><a href="#三、作用域与执行上下文" class="headerlink" title="三、作用域与执行上下文"></a>三、作用域与执行上下文</h2><p>许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。</p><p>我们知道JavaScript属于解释型语言，JavaScript的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：</p><p><strong>解释阶段：</strong></p><ul><li>词法分析</li><li>语法分析</li><li>作用域规则确定</li></ul><p><strong>执行阶段：</strong></p><ul><li>创建执行上下文</li><li>执行函数代码</li><li>垃圾回收</li></ul><p>JavaScript解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。</p><p>作用域和执行上下文之间最大的区别是：<br><strong>执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变</strong>。</p><p>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。<strong>同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this全面解析</title>
      <link href="/posts/4a95a1b.html"/>
      <url>/posts/4a95a1b.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>this关键字是JavaScript中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的作用域中。对于那些没有投入时间学习this机制的JavaScript开发者来说，this的绑定一直是一件非常令人困惑的事。</p><h2 id="二、了解this"><a href="#二、了解this" class="headerlink" title="二、了解this"></a>二、了解this</h2><p><strong>学习this的第一步是明白this既不指向函数自身也不指向函数的词法作用域，</strong>你也许被这样的解释误导过，但其实它们都是错误的。</p><p>随着函数使用场合的不同，this的值会发生变化。但总有一条原则就是<strong>JS中的this代表的是当前行为执行的主体</strong>，在JS中主要研究的都是函数中的this，但并不是说只有在函数里才有this。</p><p>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。如何的区分this呢？</p><h2 id="三、this到底是谁"><a href="#三、this到底是谁" class="headerlink" title="三、this到底是谁"></a>三、this到底是谁</h2><p>这要分情况讨论，常见有五种情况：</p><p><strong>1、函数执行时首先看函数名前面是否有”.”，有的话，”.”前面是谁,this就是谁；没有的话this就是window</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>fn<span class="token punctuation">:</span>fn<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//this->window</span>obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//this->obj</span><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//this->window</span><span class="token punctuation">}</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> oo<span class="token operator">=</span><span class="token punctuation">{</span> sum<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//this->oo</span>       <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；<span class="token comment" spellcheck="true">//this->window</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>oo<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、自执行函数中的this永远是window</strong></p><pre class="line-numbers language-js"><code class="language-js">  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//this->window })();</span>  <span class="token operator">~</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//this->window }();</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素，除了IE6~8下使用attachEvent（IE一个著名的bug）</strong></p><ul><li>DOM零级事件绑定</li></ul><pre class="line-numbers language-js"><code class="language-js">  oDiv<span class="token punctuation">.</span>onclick<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//this->oDiv</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>DOM二级事件绑定</p><pre class="line-numbers language-js"><code class="language-js">oDiv<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//this->oDiv</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在IE6~8下使用attachEvent，默认的this就是指的window对象</p></li></ul><pre class="line-numbers language-js"><code class="language-js">  oDiv<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//this->window</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们大多数时候，遇到事件绑定，如下面例子这种，对于IE6~8下使用attachEvent不必太较真</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"div1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onclick<span class="token operator">=</span>fn<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//fn中的this就是#divl</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"div1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onclick<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//this->#div1</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//this->window</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">CreateJsPerson</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//浏览器默认创建的对象就是我们的实例p1->this</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//->p1.name=name</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>writeJs<span class="token operator">=</span><span class="token keyword">function</span>（）<span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"my name is"</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span><span class="token string">",i can write Js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//浏览器再把创建的实例默认的进行返回</span><span class="token punctuation">}</span><span class="token keyword">var</span> p1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">CreateJsPerson</span><span class="token punctuation">(</span><span class="token string">"尹华芝"</span><span class="token punctuation">,</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>必须要注意一点：<strong>类中某一个属性值(方法)，方法中的this需要看方法执行的时候，前面是否有”.”,才能知道this是谁</strong>。大家不妨看下接下来的这个例子，就可明白是啥意思。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">100</span>；<span class="token comment" spellcheck="true">//this->f1</span><span class="token keyword">this</span><span class="token punctuation">.</span>getX<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//this->需要看getX执行的时候才知道</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> f1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">;</span>f1<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//->方法中的this是f1，所以f1.x=100</span><span class="token keyword">var</span> ss<span class="token operator">=</span>f1<span class="token punctuation">.</span>getX<span class="token punctuation">;</span><span class="token function">ss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//->方法中的this是window ->undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5.call、apply和bind</strong><br>我们先来看一个问题，想在下面的例子中this绑定obj,怎么实现？</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">"浪里行舟"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//this=>window</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//->Uncaught TypeError:obj.fn is not a function</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果直接绑定obj.fn(),程序就会报错。这里我们应该用fn.call(obj)就可以实现this绑定obj,接下来我们详细介绍下call方法：</p><ul><li><strong>call方法的作用:</strong></li></ul><p><strong>①首先我们让原型上的call方法执行，在执行call方法的时候，我们让fn方法中的this变为第一个参数值obj；然后再把fn这个函数执行。</strong></p><p><strong>②call还可以传值，在严格模式下和非严格模式下，得到值不一样。</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//在非严格模式下</span><span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">"浪里行舟 "</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span>num2<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num1<span class="token operator">+</span>num2<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//this->100 num1=200 num2=undefined</span>fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//this->obj num1=100 num2=200</span>fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//this->window</span>fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//this->window</span>fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//this->window</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//严格模式下 </span>fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在严格模式下this->undefined</span>fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在严格模式 下this->null</span>fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在严格模式下this->undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>apply和call方法的作用是一模一样的，都是用来改变方法的this关键字并且把方法执行，而且在严格模式下和非严格模式下对于第一个参数是null/undefined这种情况的规律也是一样的。</strong></li></ul><p>两者唯一的区别：call在给fn传递参数的时候，是一个个的传递值的，而apply不是一个个传，而是把要给fn传递的参数值统一的放在一个数组中进行操作。但是也相当子一个个的给fn的形参赋值。<br>总结一句话:<strong>call第二个参数开始接受一个参数列表,apply第二个参数开始接受一个参数数组</strong></p><pre class="line-numbers language-js"><code class="language-js">fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>bind：这个方法在IE6～8下不兼容，和call/apply类似都是用来改变this关键字的</strong>，但是和这两者有明显区别：</li></ul><pre class="line-numbers language-js"><code class="language-js">fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//->改变this和执行fn函数是一起都完成了</span>fn<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//->只是改变了fn中的this为obj，并且给fn传递了两个参数值1、2，</span>                     但是此时并没有把fn这个函数执行<span class="token keyword">var</span> tempFn<span class="token operator">=</span>fn<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">tempFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这样才把fn这个函数执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>bind体现了预处理思想：事先把fn的this改变为我们想要的结果，并且把对应的参数值也准备好，以后要用到了，直接的执行即可。</strong></p><p><strong>call和apply直接执行函数，而bind需要再一次调用。</strong></p><pre class="line-numbers language-js"><code class="language-js">  <span class="token keyword">var</span> a <span class="token operator">=</span><span class="token punctuation">{</span>        name <span class="token punctuation">:</span> <span class="token string">"Cherry"</span><span class="token punctuation">,</span>        fn <span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token operator">+</span> b<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>  b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码没有执行，bind返回改变了上下文的一个函数，我们必须要手动去调用：</p><pre class="line-numbers language-js"><code class="language-js"> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>必须要声明一点：遇到第五种情况（call apply和bind),前面四种全部让步。</strong></p><h2 id="四、箭头函数this指向"><a href="#四、箭头函数this指向" class="headerlink" title="四、箭头函数this指向"></a>四、箭头函数this指向</h2><p>箭头函数正如名称所示那样使用一个“箭头”(=&gt;)来定义函数的新语法，但它优于传统的函数,主要体现两点：<strong>更简短的函数并且不绑定this</strong>。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    birth<span class="token punctuation">:</span> <span class="token number">1990</span><span class="token punctuation">,</span>    getAge<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>birth<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1990</span>        <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>birth<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this指向window或undefined</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，箭头函数完全修复了this的指向，<strong>箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this</strong>。</p><p>换句话说，<strong>箭头函数的this看外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window</strong>。</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>测试箭头函数this_1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>测试箭头函数this_2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">           <span class="token keyword">let</span> btn1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'kobe'</span><span class="token punctuation">,</span>            age<span class="token punctuation">:</span> <span class="token number">39</span><span class="token punctuation">,</span>            getName<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                btn1<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//obj</span>                <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        obj<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上例中，由于箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。其实可以简化为如下代码:</p><pre class="line-numbers language-js"><code class="language-js">   <span class="token keyword">let</span> btn1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'kobe'</span><span class="token punctuation">,</span>            age<span class="token punctuation">:</span> <span class="token number">39</span><span class="token punctuation">,</span>            getName<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>   obj<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那假如上一层并不存在函数，this指向又是谁？</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>测试箭头函数this_1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>测试箭头函数this_2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">           <span class="token keyword">let</span> btn2 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'kobe'</span><span class="token punctuation">,</span>            age<span class="token punctuation">:</span> <span class="token number">39</span><span class="token punctuation">,</span>            getName<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                btn2<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//window</span>                <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        obj<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上例中，虽然存在两个箭头函数，其实this取决于最外层的箭头函数,由于obj是个对象而非函数，所以this指向为Window对象</p><p>由于this在箭头函数中已经按照词法作用域绑定了，所以，<strong>用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略</strong>：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    birth<span class="token punctuation">:</span> <span class="token number">1990</span><span class="token punctuation">,</span>    getAge<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>year<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>birth<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1990</span>        <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> y <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>birth<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this.birth仍是1990</span>        <span class="token keyword">return</span> fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span>birth<span class="token punctuation">:</span><span class="token number">2000</span><span class="token punctuation">}</span><span class="token punctuation">,</span> year<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token number">2018</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 28</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数据类型转换</title>
      <link href="/posts/8bc77391.html"/>
      <url>/posts/8bc77391.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript是一门动态语言，所谓的动态语言可以暂时理解为在语言中的一切内容都是不确定的。比如一个变量，这一时刻是个整型，下一时刻可能会变成字符串了。虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。</p><p>本文主要介绍数据类型强制转换和自动转换，自动转换是基于强制转换之上。<strong>强制转换主要指使用Number、String和Boolean三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。</strong></p><h2 id="一、强制转换"><a href="#一、强制转换" class="headerlink" title="一、强制转换"></a>一、强制转换</h2><h3 id="1、其他的数据类型转换为String"><a href="#1、其他的数据类型转换为String" class="headerlink" title="1、其他的数据类型转换为String"></a>1、其他的数据类型转换为String</h3><p><strong>方式一：toString()方法</strong></p><ul><li>调用被转换数据类型的toString()方法,该方法不会影响到原变量，它会将转换的结果返回，<strong>但是注意：null和undefined这两个值没有toString，如果调用他们的方法，会报错。</strong></li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span>a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//"123"</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//"报错"</span><span class="token keyword">var</span> c <span class="token operator">=</span> undefinedc<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//"报错"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>采用 Number 类型的 toString() 方法的基模式，可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> iNum <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>iNum<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出 "1010"</span><span class="token function">alert</span><span class="token punctuation">(</span>iNum<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出 "12"</span><span class="token function">alert</span><span class="token punctuation">(</span>iNum<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//输出 "A"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方式二：String()函数</strong></p><ul><li>使用String()函数做强制类型转换时，对于Number和Boolean实际上就是调用的toString()方法,<br>但是对于null和undefined，就不会调用toString()方法,它会将null直接转换为”null”,将undefined 直接转换为”undefined”</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token function">String</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//"null"</span><span class="token keyword">var</span> b <span class="token operator">=</span> undefined<span class="token function">String</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//"undefined"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Object]"</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "1,2,3"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2、其他的数据类型转换为Number"><a href="#2、其他的数据类型转换为Number" class="headerlink" title="2、其他的数据类型转换为Number"></a>2、其他的数据类型转换为Number</h3><p><strong>方式一：使用Number()函数</strong></p><p>下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象</p><p><strong>(1)原始类型值</strong></p><p>①字符串转数字</p><p>Ⅰ 如果是纯数字的字符串，则直接将其转换为数字</p><p>Ⅱ 如果字符串中有非数字的内容，则转换为NaN</p><p>Ⅲ 如果字符串是一个空串或者是一个全是空格的字符串，则转换为0</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'324'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 324</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'324abc'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>②布尔值转数字:true转成1,false转成0</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">Number</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>③undefined转数字:转成NaN</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">Number</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>④null转数字：转成0</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>⑤Number() 接受数值作为参数，此时它既能识别负的十六进制，也能识别0开头的八进制，返回值永远是十进制值</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">Number</span><span class="token punctuation">(</span><span class="token number">3.15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3.15</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token number">023</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//19</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token number">0x12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//18</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0x12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//-18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(2)对象</strong></p><p>简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>方式二：parseInt() &amp; parseFloat()</strong></p><p>这种方式专门用来对付字符串，parseInt()一个字符串转换为一个整数,可以将一个字符串中的有效的整数内容取出来，然后转换为Number。parseFloat()把一个字符串转换为一个浮点数。parseFloat()作用和parseInt()类似，不同的是它可以获得有效的小数。</p><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'.21'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//NaN</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"10.3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//10</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">'.21'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//0.21</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">'.d1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//NaN</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"10.11.33"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//10.11</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"4.3years"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//4.3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"He40.3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>parseInt()在没有第二个参数时默认以十进制转换数值，有第二个参数时，以第二个参数为基数转换数值，如果基数有误返回NaN</p><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"13"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//13</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"11"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"17"</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//15</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"1f"</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//31</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>两者的区别：Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'42 cats'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 42</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'42 cats'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。<br>另外，对空字符串的处理也不一样</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//0    </span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3、其他的数据类型转换为Boolean"><a href="#3、其他的数据类型转换为Boolean" class="headerlink" title="3、其他的数据类型转换为Boolean"></a>3、其他的数据类型转换为Boolean</h3><p>它的转换规则相对简单：<strong>只有空字符串(“”)、null、undefined、+0、-0 和 NaN 转为布尔型是 false，其他的都是 true，空数组、空对象转换为布尔类型也是 true,甚至连false对应的布尔对象new Boolean(false)也是true</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">Boolean</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、自动转换"><a href="#二、自动转换" class="headerlink" title="二、自动转换"></a>二、自动转换</h2><p>遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。</p><h3 id="1-自动转换为布尔值"><a href="#1-自动转换为布尔值" class="headerlink" title="1.自动转换为布尔值"></a>1.自动转换为布尔值</h3><p>JavaScript 遇到预期为布尔值的地方(比如if语句的条件部分),就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用Boolean函数。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// "hello"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-自动转换为数值"><a href="#2-自动转换为数值" class="headerlink" title="2.自动转换为数值"></a>2.自动转换为数值</h3><p>*<em>算数运算符(+ - * /)跟非Number类型的值进行运算时，会将这些值转换为Number，然后在运算，除了字符串的加法运算*</em></p><pre class="line-numbers language-js"><code class="language-js"><span class="token boolean">true</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment" spellcheck="true">// 2</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token keyword">null</span> <span class="token comment" spellcheck="true">// 2</span>undefined <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment" spellcheck="true">// NaN</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">NaN</span> <span class="token comment" spellcheck="true">// NaN 任何值和NaN做运算都得NaN</span><span class="token string">'5'</span> <span class="token operator">-</span> <span class="token string">'2'</span> <span class="token comment" spellcheck="true">// 3</span><span class="token string">'5'</span> <span class="token operator">*</span> <span class="token string">'2'</span> <span class="token comment" spellcheck="true">// 10</span><span class="token boolean">true</span> <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true">// 0</span><span class="token string">'1'</span> <span class="token operator">-</span> <span class="token number">1</span>   <span class="token comment" spellcheck="true">// 0</span><span class="token string">'5'</span> <span class="token operator">*</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 0</span><span class="token boolean">false</span> <span class="token operator">/</span> <span class="token string">'5'</span> <span class="token comment" spellcheck="true">// 0</span><span class="token string">'abc'</span> <span class="token operator">-</span> <span class="token number">1</span>   <span class="token comment" spellcheck="true">// NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>一元运算符也会把运算子转成数值。</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">+</span><span class="token string">'abc'</span> <span class="token comment" spellcheck="true">// NaN</span><span class="token operator">-</span><span class="token string">'abc'</span> <span class="token comment" spellcheck="true">// NaN</span><span class="token operator">+</span><span class="token boolean">true</span> <span class="token comment" spellcheck="true">// 1</span><span class="token operator">-</span><span class="token boolean">false</span> <span class="token comment" spellcheck="true">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-自动转换为字符串"><a href="#3-自动转换为字符串" class="headerlink" title="3.自动转换为字符串"></a>3.自动转换为字符串</h3><p>字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token string">'5'</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment" spellcheck="true">// '51'</span><span class="token string">'5'</span> <span class="token operator">+</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// "5true"</span><span class="token string">'5'</span> <span class="token operator">+</span> <span class="token boolean">false</span> <span class="token comment" spellcheck="true">// "5false"</span><span class="token string">'5'</span> <span class="token operator">+</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// "5[object Object]"</span><span class="token string">'5'</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// "5"</span><span class="token string">'5'</span> <span class="token operator">+</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// "5function (){}"</span><span class="token string">'5'</span> <span class="token operator">+</span> undefined <span class="token comment" spellcheck="true">// "5undefined"</span><span class="token string">'5'</span> <span class="token operator">+</span> <span class="token keyword">null</span> <span class="token comment" spellcheck="true">// "5null"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><h3 id="1-强制转换的各种情况"><a href="#1-强制转换的各种情况" class="headerlink" title="1. 强制转换的各种情况"></a>1. 强制转换的各种情况</h3><h3 id="2-自动转换的的各种情况"><a href="#2-自动转换的的各种情况" class="headerlink" title="2. 自动转换的的各种情况"></a>2. 自动转换的的各种情况</h3><ul><li>只有空字符串(“”)、null、undefined、+0、-0 和 NaN 转为布尔型是 false，其他的都是 true</li><li>除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。一元运算符也会把运算子转成数值。</li><li>字符串的自动转换，主要发生在字符串的加法运算时。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的数据类型及其检测</title>
      <link href="/posts/fcbfa8b1.html"/>
      <url>/posts/fcbfa8b1.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、JavaScript有几种类型的值？"><a href="#一、JavaScript有几种类型的值？" class="headerlink" title="一、JavaScript有几种类型的值？"></a>一、JavaScript有几种类型的值？</h2><p>Javascript有两种数据类型，分别是<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p><p>其中基本数据类型包括Undefined、Null、Boolean、Number、String、Symbol (ES6新增，表示独一无二的值)，而引用数据类型统称为Object对象，主要包括对象、数组和函数。</p><p>接下来我们分别看下两者的特点。</p><h2 id="二、基本数据类型"><a href="#二、基本数据类型" class="headerlink" title="二、基本数据类型"></a>二、基本数据类型</h2><h3 id="1-值是不可变的"><a href="#1-值是不可变的" class="headerlink" title="1. 值是不可变的"></a>1. 值是不可变的</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'java'</span><span class="token punctuation">;</span>name<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 'JAVA'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出  'java'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由此可得，基本数据类型的值是不可改变的</p><h3 id="2-存放在栈区"><a href="#2-存放在栈区" class="headerlink" title="2. 存放在栈区"></a>2. 存放在栈区</h3><p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><h3 id="3-值的比较"><a href="#3-值的比较" class="headerlink" title="3. 值的比较"></a>3. 值的比较</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>== : 只进行值的比较,会进行数据类型的转换。<br>=== : 不仅进行值得比较，还要进行数据类型的比较。</p><h2 id="三、引用数据类型"><a href="#三、引用数据类型" class="headerlink" title="三、引用数据类型"></a>三、引用数据类型</h2><h3 id="1-值是可变的"><a href="#1-值是可变的" class="headerlink" title="1. 值是可变的"></a>1. 值是可变的</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">{</span>age<span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">}</span>；a<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">21</span>；console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//21</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面代码说明引用类型可以拥有属性和方法，并且是可以动态改变的。</p><h3 id="2-同时保存在栈内存和堆内存"><a href="#2-同时保存在栈内存和堆内存" class="headerlink" title="2. 同时保存在栈内存和堆内存"></a>2. 同时保存在栈内存和堆内存</h3><p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h3 id="3-比较是引用的比较"><a href="#3-比较是引用的比较" class="headerlink" title="3. 比较是引用的比较"></a>3. 比较是引用的比较</h3><p>当从一个变量向另一个变量赋引用类型的值时，同样也会将存储在变量中的对象的值复制一份放到为新变量分配的空间中。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">{</span>age<span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> b<span class="token operator">=</span>a<span class="token punctuation">;</span>b<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">21</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>age<span class="token operator">==</span>b<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面我们讲到基本类型和引用类型存储于内存的位置不同，引用类型存储在堆中的对象，与此同时，在栈中存储了指针，而这个指针指向正是堆中实体的起始位置。变量a初始化时，a指针指向对象{age:20}的地址，a赋值给b后,b又指向该对象{age:20}的地址，这两个变量指向了同一个对象。因此，改变其中任何一个变量，都会相互影响。</p><p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">{</span>age<span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> b<span class="token operator">=</span>a<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>b <span class="token comment" spellcheck="true">// {age:20}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，a和b指向同一个对象，然后a的值变为1，这时不会对b产生影响，b还是指向原来的那个对象。</p><h2 id="四、检验数据类型"><a href="#四、检验数据类型" class="headerlink" title="四、检验数据类型"></a>四、检验数据类型</h2><h3 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1. typeof"></a>1. typeof</h3><p><strong>typeof返回一个表示数据类型的字符串</strong>，返回结果包括：number、boolean、string、symbol、object、undefined、function等7种数据类型，但不能判断null、array等</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// symbol 有效</span><span class="token keyword">typeof</span> <span class="token string">''</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string 有效</span><span class="token keyword">typeof</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// number 有效</span><span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//boolean 有效</span><span class="token keyword">typeof</span> undefined<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//undefined 有效</span><span class="token keyword">typeof</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// function 有效</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//object 无效</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//object 无效</span><span class="token keyword">typeof</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//object 无效</span><span class="token keyword">typeof</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//object 无效</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组和对象返回的都是object，这时就需要使用instanceof来判断</p><h3 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2. instanceof"></a>2. instanceof</h3><p>instanceof 是用来判断A是否为B的实例，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。<strong>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span><span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span><span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>关于数组的类型判断，还可以用ES6新增Array.isArray()</p><pre class="line-numbers language-js"><code class="language-js">Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>instanceof 三大弊端：</strong></p><ul><li>对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建的是有一定的区别的</li></ul><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从严格意义上来讲，只有实例创建出来的结果才是标准的对象数据类型值，也是标准的Number这个类的一个实例；对于字面量方式创建出来的结果是基本的数据类型值，不是严谨的实例，但是由于JS的松散特点，导致了可以使用Number.prototype上提供的方法。</p><ul><li>只要在当前实例的原型链上，我们用其检测出来的结果都是true。<strong>在类的原型继承中，我们最后检测出来的结果未必准确。</strong></li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>不能检测null 和 undefined</li></ul><p><strong>对于特殊的数据类型null和undefined，他们的所属类是Null和Undefined，但是浏览器把这两个类保护起来了，不允许我们在外面访问使用。</strong></p><h3 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3. constructor"></a>3. constructor</h3><p>constructor作用和instanceof非常相似。<strong>但constructor检测 Object与instanceof不一样，还可以处理基本数据类型的检测。</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> aa<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>aa<span class="token punctuation">.</span>constructor<span class="token operator">===</span>Array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>aa<span class="token punctuation">.</span>constructor<span class="token operator">===</span>RegExp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor<span class="token operator">===</span>Number<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span><span class="token keyword">var</span> reg<span class="token operator">=</span><span class="token regex">/^$/</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span>constructor<span class="token operator">===</span>RegExp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span>constructor<span class="token operator">===</span>Object<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>constructor 两大弊端：</strong></p><ul><li><p>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</p></li><li><p>函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写，在重写的过程中很有可能出现把之前的constructor给覆盖了，这样检测出来的结果就是不准确的</p></li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>Fn<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//Array</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-Object-prototype-toString-call"><a href="#4-Object-prototype-toString-call" class="headerlink" title="4. Object.prototype.toString.call()"></a>4. Object.prototype.toString.call()</h3><p><strong>Object.prototype.toString.call() 最准确最常用的方式</strong>。首先获取Object原型上的toString方法，让方法执行，让toString方法中的this指向第一个参数的值。</p><p><strong>关于toString重要补充说明</strong>：</p><ul><li>本意是转换为字符串，但是某些toString方法不仅仅是转换为字符串</li><li>对于Number、String，Boolean，Array，RegExp、Date、Function原型上的toString方法都是把当前的数据类型转换为字符串的类型（它们的作用仅仅是用来转换为字符串的）</li><li>Object上的toString并不是用来转换为字符串的。</li></ul><p>Object上的toString它的作用是返回当前方法执行的主体（方法中的this）所属类的详细信息即”[object Object]”,其中第一个object代表当前实例是对象数据类型的(这个是固定死的)，第二个Object代表的是this所属的类是Object。</p><pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// [object String]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// [object Number]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Boolean]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Undefined]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Null]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Function]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Date]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Array]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object RegExp]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Error]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object HTMLDocument]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[object global] window是全局对象global的引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化</title>
      <link href="/posts/616f4683.html"/>
      <url>/posts/616f4683.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>要说起前端性能优化，其实我们可以从 “输入 URL 到页面呈现” 这个知识点着手讲起。</p><p>在用户输入 URL，按下回车之后，走过的步骤：</p><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器响应</li><li>浏览器解析渲染页面</li></ol><p>这其中可以做到哪些优化呢？下面再对这些知识点进行梳理</p><h3 id="1-1-DNS解析"><a href="#1-1-DNS解析" class="headerlink" title="1.1 DNS解析"></a>1.1 DNS解析</h3><p>DNS 解析过程是一个知识点，详细可看：<a href="https://ruimintan.github.io/posts/9e319110.html">DNS解析</a></p><p>首先需要知道的是 DNS 解析的开始步骤：<strong>浏览器 DNS 缓存 -&gt; 系统缓存（host） -&gt; 路由器缓存</strong></p><p>浏览器 DNS 缓存：你不确定，也无法帮用户缓存；</p><p>系统缓存（host）：你自己修改 host 文件都要权限，修改用户的就更不靠谱了；</p><p>路由器缓存：用户家的路由器……</p><p>然后本地服务器向根服务器、顶级域名服务器、主域名服务器这些的请求就更不用说了，前端没法接触。</p><p>所以这个步骤我们忽略先。</p><h3 id="1-2-TCP连接"><a href="#1-2-TCP连接" class="headerlink" title="1.2 TCP连接"></a>1.2 TCP连接</h3><p>详细文章<a href="https://ruimintan.github.io/posts/989d5490.html">TCP/UDP详解</a><br>这个步骤我们也忽略，前端性能优化暂时管不到它。</p><h3 id="1-3-发送-HTTP-请求"><a href="#1-3-发送-HTTP-请求" class="headerlink" title="1.3 发送 HTTP 请求"></a>1.3 发送 HTTP 请求</h3><p>发送 HTTP 请求这块，我们可以通过 4 点进行讲解：</p><ul><li><p><strong>浏览器缓存</strong><br>HTTP 请求发起的时候，我们可以利用浏览器缓存，看采用强缓存还是协商缓存，这样我们对于有缓存的页面可以快速加载。</p></li><li><p><strong>Cookie 和 WebStorage</strong><br>利用 Cookie 和 WebStorage 对一些无关紧要的数据进行缓存，方便利用。</p></li><li><p><strong>CDN 的使用</strong><br>静态资源的请求可以采用 CDN，减少服务器压力、防止不必要携带 Cookie 的场景等。</p></li><li><p><strong>负载均衡</strong><br>利用负载均衡的特点，开启 Node.js 方面的 PM2 或者 Nginx 的反向代理，轮询服务器，平均各个服务器的压力。</p></li></ul><h3 id="1-4-服务器响应"><a href="#1-4-服务器响应" class="headerlink" title="1.4 服务器响应"></a>1.4 服务器响应</h3><p>在服务器响应的时候，我们也可以做 4 部分：</p><ul><li><p><strong>Webpack 优化</strong><br>在发布项目到服务器之前，我们可以利用一些可视化插件进行分析，使用 Happypack 等提高打包效率，项目内容上可以做按需加载、tree shaking 等。</p></li><li><p><strong>图片优化</strong><br>我们需要熟悉了解 JPG/JPEG、PNG-8/PNG-24、GIF、Base64、SVG 这些图片的特性，然后通过 Webpack 的 url-loader 将一些小图标转换成 Base64，一些 Icon 使用 SVG，一些轮播图、Banner 图用 JPG/JPGE、雪碧图的使用等。</p></li><li><p><strong>Gzip 压缩</strong><br>Gzip 压缩的原理是在一个文本文件中找一些重复出现的字符串、临时替换它们，从而使整个文件变小（对于图片等会处理不了）。我们可以通过 Webpack 的 ComparessionPlugin 进行 Gzip 压缩，然后在 Nginx 上进行配置，就可以利用好 Gzip 了。</p></li><li><p><strong>服务端渲染（SSR）</strong><br>服务端渲染是指浏览器请求的时候，服务端将已经渲染好的 HTML 页面直接返回给浏览器，浏览器直接加载它的 HTML 渲染即可，减少了前后端交互，对 SEO 更友好。</p></li></ul><h3 id="1-5-浏览器解析渲染页面"><a href="#1-5-浏览器解析渲染页面" class="headerlink" title="1.5 浏览器解析渲染页面"></a>1.5 浏览器解析渲染页面</h3><p>浏览器解析渲染页面的过程是：</p><ol><li>解析 HTML，生成 DOM 树</li><li>解析 CSS，生成 CSS 规则树（CSS Rule Tree）</li><li>将 DOM Tree 和 CSS Rule Tree 相结合，生成 渲染树（Render Tree）</li><li>从根节点开始，计算每一个元素的大小、位置，给出每个节点所应该出现的屏幕精确坐标，从而得到基于渲染树的 布局渲染树（Layout of the render tree）。</li><li>遍历渲染树，将每个节点用 UI 渲染引擎来绘制，从而将整棵树绘制到页面上，这个步骤叫 绘制渲染树（Painting the render tree）</li></ol><p>关于这个步骤我们的优化方案有：</p><ol><li><strong>CSS 选择器解析问题。</strong> 编码过程中用尽可能少的选择器来表示一个元素，因为 CSS 是从右往左加载的。</li><li><strong>CSS 加载问题。</strong> 尽可能在 head 位置加载 CSS，减少 HTML 加载完毕需要等待 CSS 加载的问题。</li><li><strong>JS 加载问题。</strong> JS 的加载会阻塞 HTML 和 CSS 的加载，所以 script 标签通常放 body 后面，同时可以利用 script 标签的 async 和 defer 属性，同步加载 JS 或者等 HTML 和 CSS 加载渲染完后再加载 JS。</li><li><strong>DOM 渲染问题。</strong> DOM 渲染的时候可能会触发回流和重绘，应该尽量避免触发。</li></ol><p>如何避免触发回流：</p><ol><li>【CSS】使用 visibility 替换 display</li><li>【CSS】避免 table 布局。对于 Render Tree 的计算通常只需要遍历一次就可以完成，但是 table 布局需要计算多次，通常要花 3 倍于等同元素的时间，因此要避免。</li><li>【JS】避免频繁做 width、height 等会触发回流的操作。</li><li>【JS】操作 DOM 的时候，如果是添加 DOM 节点，可以将所有节点都在 JS 中操作完毕，再进行渲染（一次性）</li></ol><h3 id="1-6-其他"><a href="#1-6-其他" class="headerlink" title="1.6 其他"></a>1.6 其他</h3><p>除此之外，我们还可以通过：</p><ul><li>Chrome 插件可视化判断页面哪些部分可进行优化</li><li>长列表使用懒加载</li><li>preload 预加载页面</li></ul><p>等进行性能优化相关操作。</p><h3 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h3><p>以上，我们通过 6 个部分，串起来讲解了前端性能优化部分的知识点。</p><p>下面我们逐一详细的过一下上面讲到的优化知识点。</p><h2 id="二、浏览器缓存"><a href="#二、浏览器缓存" class="headerlink" title="二、浏览器缓存"></a>二、浏览器缓存</h2><p>浏览器缓存可以简单地理解为 HTTP 缓存。</p><h3 id="2-1-缓存位置"><a href="#2-1-缓存位置" class="headerlink" title="2.1 缓存位置"></a>2.1 缓存位置</h3><p>浏览器缓存位置分 4 个部分：</p><ul><li>Service Worker Cache - 运行在浏览器背后的独立线程。一般可以用来实现缓存功能。</li><li>Menory Cache - 内存中的缓存。主要是页面上已经下载的样式、脚本、图片等已经抓取到的资源。</li><li>Disk Cache - 硬盘中的缓存。读取速度相对慢点。</li><li>Push Cache - 推送缓存。 是 HTTP2 中的内容，当以上 3 种缓存都没有命中的时候，它才会被使用。</li></ul><h3 id="2-2-缓存机制"><a href="#2-2-缓存机制" class="headerlink" title="2.2 缓存机制"></a>2.2 缓存机制</h3><ul><li><strong>强缓存</strong><br>强缓存优先于协商缓存进行，若强制缓存生效则直接使用缓存，若不生效则进行协商缓存。强缓存不会向服务器发送请求，直接从缓存中读取资源。</li></ul><p>强缓存利用 HTTP 请求头的 Expires 和 Cache-Control 两个字段来控制。</p><ul><li><strong>协商缓存</strong><br>协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器中；生效则返回 304，继续使用缓存。</li></ul><p>协商缓存利用 Last-Modified + If-Modified-Since 和 Etag + If-None-Match 来实现。</p><p>具体的缓存过程小伙伴们可以看<a href="https://ruimintan.github.io/posts/260ad1cb.html">浏览器缓存</a>篇章。</p><h2 id="三、Cookie、Web-Storage-和-IndexDB"><a href="#三、Cookie、Web-Storage-和-IndexDB" class="headerlink" title="三、Cookie、Web Storage 和 IndexDB"></a>三、Cookie、Web Storage 和 IndexDB</h2><h3 id="3-1-Cookie"><a href="#3-1-Cookie" class="headerlink" title="3.1 Cookie"></a>3.1 Cookie</h3><p>Cookie 最开始被设计出来其实并不是来做本地存储的，而是为了弥补 HTTP 在状态管理上的不足。</p><p>Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。</p><p>向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。</p><p>缺陷：</p><ol><li><strong>容量缺陷</strong>。体积上线 4kb，只能存储少量信息。</li><li><strong>性能缺陷</strong>。Cookie 请求每次都会携带上完整的 Cookie，随着请求数增多，造成性能浪费。</li><li><strong>安全缺陷</strong>。以纯文本的形式在浏览器和服务器中传递，容易被非法截获和篡改。</li></ol><h3 id="3-2-Local-Storage"><a href="#3-2-Local-Storage" class="headerlink" title="3.2 Local Storage"></a>3.2 Local Storage</h3><p>Local Storge 也是针对同一个域名。</p><p>同一个域名下，会存储相同的一段 Local Storage。</p><p>相比 Cookie 优势：</p><ol><li><strong>容量</strong>。体积上线 5M，大于 Cookie 的 4kb。</li><li><strong>只存在客户端</strong>。不参与和服务端的通讯，避免 Cookie 的性能缺陷和安全缺陷。</li><li><strong>接口封装</strong>。有 setItem 和 getItem 两个 API 接口。</li></ol><p>应用场景：</p><ul><li>以 Base64 方式存储官方 Logo 等图片。</li></ul><h3 id="3-3-Session-Storage"><a href="#3-3-Session-Storage" class="headerlink" title="3.3 Session Storage"></a>3.3 Session Storage</h3><p>基本上和 Local Stoarge 一致。</p><p>相比较上的不同：</p><ul><li>会话级别的存储。不同于 Local Storage 的持续化存储，Session Storage 当页面关闭的时候就不复存在了。</li></ul><p><strong>应用场景</strong>：</p><ol><li>对表单信息做维护。用户刷新页面不丢失。</li><li>存储本次浏览记录。看过的页面不怕找不到。</li></ol><h3 id="3-4-IndexDB"><a href="#3-4-IndexDB" class="headerlink" title="3.4 IndexDB"></a>3.4 IndexDB</h3><p>IndexedDB 是运行在浏览器中的 <strong>非关系型数据库</strong>。</p><p>因为本质上是数据库，所以一般来说容量是没有上线的。</p><h2 id="四、CDN"><a href="#四、CDN" class="headerlink" title="四、CDN"></a>四、CDN</h2><p>返回目录</p><p>CDN（Content Delivery Network，内容分发网络）指的是一组分布在各个地区的服务器。</p><p>这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。</p><p>CDN 提供快速服务，较少受高流量影响。</p><p>假设有一部影片出版，非常多人看。jsliang 在广州，请求上海的服务器，结果这个服务器非常多人，资源响应地很慢。于是 jsliang 切换了路线，看到深圳服务器也有这个资源，于是向深圳服务器请求，结果能很快地看到这部影片。</p><p>在这个场景中，深圳服务器就扮演 CDN 的角色。</p><p>CDN 的核心：<strong>缓存</strong> 和 <strong>回源</strong>。</p><ul><li><strong>缓存</strong>：将资源 copy 一份到 CDN 服务器。</li><li><strong>回源</strong>：CDN 发现自己没有这个资源，转头向根服务器（上级服务器）请求这个资源。</li></ul><p><strong>应用场景</strong>：</p><ol><li>公司静态资源部署到就近的服务器，利用 CDN 特性方便访问</li><li>jQuery 等框架可以引用 CDN，加快网站的加载速度，避免同一个服务器加载的限制。</li><li>减少 Cookie 影响。同一个域名下，请求静态资源会携带 Cookie 信息，但是我们并不需要，所以使用 CDN 可以避免不必要的 Cookie 出现场景。</li></ol><h2 id="五、负载均衡"><a href="#五、负载均衡" class="headerlink" title="五、负载均衡"></a>五、负载均衡</h2><p>如果是大型网站，负载均衡是不可或缺的内容。</p><ul><li>PM2：一款 Node.js 进程管理器，让计算机每一个内核都启动一个 Node.js 服务，并且实现自动控制负载均衡。</li><li>Nginx：通过轮询机制，将用户的请求分配到压力较小的服务器上（反向代理）。</li></ul><p>区别：反向代理是对服务器实现负载均衡，而 PM2 是对进程实现负载均衡。</p><h2 id="六、Webpack-优化"><a href="#六、Webpack-优化" class="headerlink" title="六、Webpack 优化"></a>六、Webpack 优化</h2><p>Webpack 的优化瓶颈，主要是 2 个方面：</p><ul><li>Webpack 的构建过程太花时间</li><li>Webpack 打包的结果体积太大</li></ul><h3 id="6-1-针对-Webpack-本身构建优化"><a href="#6-1-针对-Webpack-本身构建优化" class="headerlink" title="6.1 针对 Webpack 本身构建优化"></a>6.1 针对 Webpack 本身构建优化</h3><h4 id="6-1-1-优化-resolve-modules-配置"><a href="#6-1-1-优化-resolve-modules-配置" class="headerlink" title="6.1.1 优化 resolve.modules 配置"></a>6.1.1 优化 resolve.modules 配置</h4><p>resolve.modules 用于配置 Webpack 去哪些目录下寻找第三方模块，默认是 [‘node_modules’]，但是，它会先去当前目录的 ./node_modules 查找，没有的话再去 ../node_modules，最后到根目录。</p><p>所以可以直接指定项目根目录，就不需要一层一层查找。</p><pre class="line-numbers language-js"><code class="language-js">resolve<span class="token punctuation">:</span> <span class="token punctuation">{</span>  modules<span class="token punctuation">:</span> <span class="token punctuation">[</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'node_modules'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="6-1-2-优化-resolve-extensions-配置"><a href="#6-1-2-优化-resolve-extensions-配置" class="headerlink" title="6.1.2 优化 resolve.extensions 配置"></a>6.1.2 优化 resolve.extensions 配置</h4><p>在导入没带文件后缀的路径时，Webpack 会自动带上后缀去尝试询问文件是否存在，而 resolve.extensions 用于配置尝试后缀列表；默认为 extensions:[‘js’, ‘json’]。</p><p>当遇到 require(‘./data’) 时 Webpack 会先尝试寻找 data.js，没有再去找 data.json；如果列表越长，或者正确的后缀越往后，尝试的次数就会越多。</p><p>所以在配置时为提升构建优化需遵守：</p><ol><li>频率出现高的文件后缀优先放在前面。</li><li>列表尽可能的少，例如只有 3 个：js、jsx、json。</li><li>书写导入语句时，尽量写上后缀名。</li></ol><h3 id="6-2-通过-Loader-和-Plugin-优化"><a href="#6-2-通过-Loader-和-Plugin-优化" class="headerlink" title="6.2 通过 Loader 和 Plugin 优化"></a>6.2 通过 Loader 和 Plugin 优化</h3><h4 id="6-2-1-babel-loader"><a href="#6-2-1-babel-loader" class="headerlink" title="6.2.1 babel-loader"></a>6.2.1 babel-loader</h4><p>以 babel-loader 为例，可以通过 include 和 exclude 帮助我们避免 node_modules 这类庞大文件夹。</p><h4 id="6-2-2-tree-shaking"><a href="#6-2-2-tree-shaking" class="headerlink" title="6.2.2 tree shaking"></a>6.2.2 tree shaking</h4><p>通过 ES6 的 import/export 来检查未引用代码，以及 sideEffects 来标记无副作用代码，最后用 UglifyJSPlugin 来做 tree shaking，从而删除冗余代码。</p><h4 id="6-2-3-可视化分析"><a href="#6-2-3-可视化分析" class="headerlink" title="6.2.3 可视化分析"></a>6.2.3 可视化分析</h4><ul><li>speed-measure-webpack-plugin：测量出在构建过程中，每一个 Loader 和 Plugin 的执行时长。</li><li>webpack-bundle-analyzer：通过矩阵树图的方式将包内各个模块的大小和依赖关系呈现出来。</li><li>webpack-chart</li><li>webpack-analyse</li></ul><h4 id="6-2-4-缓存"><a href="#6-2-4-缓存" class="headerlink" title="6.2.4 缓存"></a>6.2.4 缓存</h4><ul><li>cache-loader<br>参考链接：<a href="https://www.npmjs.com/package/cache-loader">cache-loader</a></li></ul><p>在 babel-loader 开启 cache 后，将 loader 的编译结果写进硬盘缓存，再次构建如果文件没有发生变化则会直接拉取缓存。</p><ul><li>uglifyjs-webpack-plugin<br>也可以解决缓存问题。</li></ul><h4 id="6-2-5-多进程"><a href="#6-2-5-多进程" class="headerlink" title="6.2.5 多进程"></a>6.2.5 多进程</h4><p>Happypack 可以将任务分解成多个子进程去并发执行，大大提升打包效率。</p><h4 id="6-2-6-抽离"><a href="#6-2-6-抽离" class="headerlink" title="6.2.6 抽离"></a>6.2.6 抽离</h4><p>通过 DllPlugin 或者 Externals 进行静态依赖包的分离。</p><p>由于 CommonsChunkPlugin 每次构建会重新构建一次 vendor，所以出于效率考虑，使用 DllPlugin 将第三方库单独打包到一个文件中，只有依赖自身发生版本变化时才会重新打包。</p><h4 id="6-2-7-多进程代码压缩"><a href="#6-2-7-多进程代码压缩" class="headerlink" title="6.2.7 多进程代码压缩"></a>6.2.7 多进程代码压缩</h4><p>因为自带的 UglifyJsPlugin 压缩插件是单线程运行的，而 ParallelUglifyPlugin 可以并行执行。</p><p>所以通过 ParallelUglifyPlugin 代替自带的 UglifyJsPlugin 插件。</p><h4 id="6-2-8-拆包"><a href="#6-2-8-拆包" class="headerlink" title="6.2.8 拆包"></a>6.2.8 拆包</h4><p>在 Webpack 中，到底什么是代码分离？代码分离允许你把代码拆分到多个文件中。如果使用得当，你的应用性能会提高很多。因为浏览器能缓存你的代码。</p><p>每当你做出一次修改，包含修改的文件需要被所有访问你网站的人重新下载。但你并不会经常修改应用的依赖库。</p><p>如果你能把那些依赖库拆分到完全分离的文件中，即使业务逻辑发生了更改，访问者也不需要再次下载依赖库，直接使用之前的缓存就可以了。</p><p>由于有了 SplitChunksPlugin，你可以把应用中的特定部分移至不同文件。如果一个模块在不止一个 chunk 中被使用，那么利用代码分离，该模块就可以在它们之间很好地被共享。</p><h4 id="6-2-9-打包资源压缩"><a href="#6-2-9-打包资源压缩" class="headerlink" title="6.2.9 打包资源压缩"></a>6.2.9 打包资源压缩</h4><ul><li>JS 压缩：UglifyJSPlugin</li><li>HTML 压缩：HtmlWebpackPlugin</li><li>提取公共资源：splitChunks.cacheGroups</li><li>CSS 压缩：MiniCssExtractPlugin</li><li>Gzip 压缩：不包括图片</li></ul><h4 id="6-2-10-按需加载"><a href="#6-2-10-按需加载" class="headerlink" title="6.2.10 按需加载"></a>6.2.10 按需加载</h4><p>通过 Code-Splitting 来做 React 的按需加载.</p><p>Code_Splitting 核心是 require-ensure。</p><h3 id="6-3-优化体验"><a href="#6-3-优化体验" class="headerlink" title="6.3 优化体验"></a>6.3 优化体验</h3><ul><li><a href="https://www.npmjs.com/package/progress-bar-webpack-plugin">progress-bar-webpack-plugin</a>：在终端底部，将会有一个构建的进度条，可以让你清晰的看见构建的执行进度。</li><li><a href="https://www.npmjs.com/package/webpack-build-notifier">webpack-build-notifier</a>：在构建完成时，能够像微信、Lark 这样的 APP 弹出消息的方式，提示构建已经完成。</li><li><a href="https://juejin.cn/post/6844903924806189070">webpack-dashboard</a>：对 Webpack 原始的构建输出不满意的话，也可以使用这样一款 Plugin 来优化你的输出界面。</li></ul><h2 id="七、图片优化"><a href="#七、图片优化" class="headerlink" title="七、图片优化"></a>七、图片优化</h2><h3 id="7-1-JPEG-与-JPG"><a href="#7-1-JPEG-与-JPG" class="headerlink" title="7.1 JPEG 与 JPG"></a>7.1 JPEG 与 JPG</h3><ul><li>关键字：有损压缩、体积小、加载快、不支持透明</li><li>优点：压缩一定程度能保持品质、体积小、请求速度快</li><li>缺点：处理矢量图形、Logo 等线条感较强，颜色对比强烈的图形，人为压缩会导致图片模糊明显。不支持透明度处理。</li><li>使用场景：大的背景图、轮播图或者 Banner 图。</li></ul><h3 id="7-2-PNG-8-与-PNG-24"><a href="#7-2-PNG-8-与-PNG-24" class="headerlink" title="7.2 PNG-8 与 PNG-24"></a>7.2 PNG-8 与 PNG-24</h3><ul><li>关键字：无损压缩、质量高、体积大、支持透明</li><li>优点：PNG-8 支持 256 种颜色，PNG-24 支持 1600 种颜色。更强的色彩表现力，对线条的处理- 更加细腻，对透明度有良好的支持。</li><li>缺点：体积较大<br>使用场景：Logo、颜色简单且对比强烈的图片和背景。</li></ul><h3 id="7-3-GIF"><a href="#7-3-GIF" class="headerlink" title="7.3 GIF"></a>7.3 GIF</h3><ul><li>关键字：动态图、体积小支持透明</li><li>优点：可以压缩体积非常小。可插入多帧实现动画效果。支持透明色浮现于背景之上。</li><li>缺点：最多只能处理 256 中颜色，不适用于真彩图像。</li><li>使用场景：小动画。</li></ul><h3 id="7-4-SVG"><a href="#7-4-SVG" class="headerlink" title="7.4 SVG"></a>7.4 SVG</h3><ul><li>关键字：文本文件、体积小、不失真、兼容性好</li><li>优点：文本体积更小，可压缩性更强。图片可以无限放大不失真。文本文件可以直接在 HTML 中写入，灵活性高。</li><li>缺点：渲染成本高、学习成本（可编程）</li><li>使用场景：变成代码嵌入 HTML 中，也可以换成 .svg 后缀的文件进行引用。</li></ul><h3 id="7-5-Base64"><a href="#7-5-Base64" class="headerlink" title="7.5 Base64"></a>7.5 Base64</h3><ul><li>关键字：文本文件、依赖编码、小图标解决方案</li><li>优点：作为雪碧图的补充而存在，减少加载页面图片时对服务器的请求次数。（img src 会发起资源请求，但是 Base64 得到的是字符串，嵌入 HTML 中）</li><li>缺点：大图使用 Base64 会增大体积，影响性能</li><li>使用场景：小 Logo（不超过 2kb）、更新频率低的图片。</li><li>编码工具：Webpack 的 url-loader 可以根据文件大小来判断是否编码成 Base64。</li></ul><h3 id="7-6-雪碧图"><a href="#7-6-雪碧图" class="headerlink" title="7.6 雪碧图"></a>7.6 雪碧图</h3><p>雪碧图、CSS 精灵、CSS Sprites、图像精灵，都是同一个玩意。</p><p>它是将小图标和背景图像合并到一张图片上，然后通过 CSS 背景定位来显示其中的每一个具体部分。</p><p>它是一种优化手段，因为单张图片所需的 HTTP 请求更少，对内存和带宽更加友好。</p><h3 id="7-7-WebP"><a href="#7-7-WebP" class="headerlink" title="7.7 WebP"></a>7.7 WebP</h3><ul><li>关键字：年轻的全能型选手</li><li>优点：支持有损压缩和无损压缩、支持透明、可以跟 GIF 一样显示动态图</li><li>缺点：兼容性差</li><li>使用场景：暂无大型应用场景</li></ul><h2 id="八、Gzip-压缩"><a href="#八、Gzip-压缩" class="headerlink" title="八、Gzip 压缩"></a>八、Gzip 压缩</h2><ul><li><p>Webpack 开启 Gzip<br>通过 compression-webpack-plugin 可以开启 Gzip 压缩。</p></li><li><p>是否值得开启 Gzip<br>如果压缩文件太小，那不使用；但是如果具有一定规模的项目文件，可以开启 Gzip。</p></li><li><p>Gzip 原理<br>Gzip 并不是万能的，它的原理是在一个文本文件中找一些重复出现的字符串、临时替换它们，从而使整个文件变小，所以对于图片等会处理不了。</p></li><li><p>服务器端和 Webpack 的 Gzip 并存<br>服务器压缩也需要时间开销和 CPU 开销，所以有时候可以用 Webpack 来进行 Gzip 压缩，从而为服务器分压。</p></li></ul><h2 id="九、服务端渲染"><a href="#九、服务端渲染" class="headerlink" title="九、服务端渲染"></a>九、服务端渲染</h2><ul><li>什么是服务端渲染（服务端渲染的运行机制）</li><li>为什么要用服务端渲染（服务端渲染解决了什么性能问题）</li><li>怎么做服务端渲染（服务端渲染的应用实例和使用场景）</li></ul><h3 id="9-1-客户端渲染和服务端渲染"><a href="#9-1-客户端渲染和服务端渲染" class="headerlink" title="9.1 客户端渲染和服务端渲染"></a>9.1 客户端渲染和服务端渲染</h3><p>客户端渲染中，页面上呈现的内容，在 HTML 源文件中往往找不到。</p><p>而服务端渲染，当用户第一次请求页面时，服务器会把需要的组件或者页面渲染成 HTML 字符串，返回给客户端。</p><p>即客户端直接拿到 HTML 内容，而不需要跑一遍 JS 去生成 DOM 内容。</p><p>“所见即所得”，服务端渲染情景下，页面上呈现的内容，在 HTML 源文件里面也可以找到。</p><h3 id="9-2-解决的性能问题"><a href="#9-2-解决的性能问题" class="headerlink" title="9.2 解决的性能问题"></a>9.2 解决的性能问题</h3><p>假设 A 网站关键字上有 <strong>前端性能优化</strong>，但是这篇文章只有 A 网站服务器搜索过后才会出来结果，这时候搜索引擎是无法找到的。</p><p>为了更好的 SEO 效果，就要拿 “现成的内容” 给搜索引擎看，就要开启服务端渲染。</p><p>其次，服务端渲染解决了一个性能问题 —— 首屏加载速度过慢。</p><p>从输入 URL 到页面渲染过程中我们知道，如果是客户端渲染，我们需要加载 HTML、CSS，然后再经过 JS 形成 Render Tree，定位后再绘制页面。</p><p>这个过程中用户一直在等待，如果采用了服务端渲染，那么服务端可以直接给一个可以拿来呈现给用户的页面。</p><h3 id="9-3-如何使用服务端渲染"><a href="#9-3-如何使用服务端渲染" class="headerlink" title="9.3 如何使用服务端渲染"></a>9.3 如何使用服务端渲染</h3><ul><li>如何给 React 开启服务端渲染</li><li>如何给 Vue 开启服务端渲染</li></ul><p>给 React 开启：</p><blockquote><p>前端项目 - VDOM.js</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span><span class="token keyword">const</span> VDom <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>我是一个被渲染为真实 DOM 的虚拟 DOM<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> VDom<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Node 项目 - index.js</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> express <span class="token keyword">from</span> <span class="token string">'express'</span><span class="token punctuation">;</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> renderToString <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-dom/server'</span><span class="token punctuation">;</span><span class="token keyword">import</span> VDom <span class="token keyword">from</span> <span class="token string">'./VDom'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个 express 应用</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// renderToString 是把虚拟 DOM 转化为真实 DOM 的关键方法</span><span class="token keyword">const</span> RDom <span class="token operator">=</span> <span class="token function">renderToString</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>VDom <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 编写 HTML 模板，插入转化后的真实 DOM 内容</span><span class="token keyword">const</span> Page <span class="token operator">=</span> <span class="token template-string"><span class="token string">`&lt;html>  &lt;head>    &lt;title>test&lt;/title>  &lt;/head>  &lt;body>    &lt;span>服务端渲染出了真实 DOM:  &lt;/span>    </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>RDom<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">  &lt;/body>&lt;/html>`</span></span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 配置 HTML 内容对应的路由</span>app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/index'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>Page<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 配置端口号</span><span class="token keyword">const</span> server <span class="token operator">=</span> app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>VDom 组件已经被 renderToString 转化为了一个内容为 &lt;div data-reactroot=””&gt; 我是一个被渲染为真实 DOM 的虚拟 DOM &lt;/div&gt; 的字符串，这个字符串被插入 HTML 代码，成为了真实 DOM 树的一部分。</p><p>至于 Vue 的可以看：<a href="https://ssr.vuejs.org/zh/">服务器端渲染 (SSR)</a>？</p><h3 id="9-4-服务端渲染小结"><a href="#9-4-服务端渲染小结" class="headerlink" title="9.4 服务端渲染小结"></a>9.4 服务端渲染小结</h3><p>SSR 主要用于解决单页应用首屏渲染慢以及 SEO 问题，同时也解决了与后端同学的沟通成本。但同时：提高了服务器压力，吃 CPU，内存等资源，优化不好提高成本。</p><h2 id="十、浏览器渲染机制"><a href="#十、浏览器渲染机制" class="headerlink" title="十、浏览器渲染机制"></a>十、浏览器渲染机制</h2><p>浏览器内核决定了浏览器解释网页语法的方式。</p><p>目前常见的浏览器内核有：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。</p><h3 id="10-1-浏览器渲染步骤"><a href="#10-1-浏览器渲染步骤" class="headerlink" title="10.1 浏览器渲染步骤"></a>10.1 浏览器渲染步骤</h3><p>浏览器的渲染过程为：</p><ol><li>解析 HTML，生成 DOM 树</li><li>解析 CSS，生成 CSS 规则树（CSS Rule Tree）</li><li>将 DOM Tree 和 CSS Rule Tree 相结合，生成 渲染树（Render Tree）</li><li>从根节点开始，计算每一个元素的大小、位置，给出每个节点所应该出现的屏幕精确坐标，从而得到基于渲染树的 布局渲染树（Layout of the render tree）。</li><li>遍历渲染树，将每个节点用 UI 渲染引擎来绘制，从而将整棵树绘制到页面上，这个步骤叫 绘制渲染树（Painting the render tree）</li></ol><h3 id="10-2-优化-CSS-选择器问题"><a href="#10-2-优化-CSS-选择器问题" class="headerlink" title="10.2 优化 - CSS 选择器问题"></a>10.2 优化 - CSS 选择器问题</h3><p>我们正常的阅读顺序是从左往右的，但是 CSS 解析器解析 CSS 的时候，采用的是古人的规则。</p><blockquote><p>#ul li {}</p></blockquote><p>这样的一行规则，我们写起来的时候很顺畅：先找 id 为 ul 的元素，再找里面的 li 元素。</p><p>但是实际上 CSS 解析器是从右往左的，它会先查找所有 li 元素，并且逐个确认这个 li 元素的父元素的 id 是不是 ul，这就坑死了。</p><p>所以像通配符  * { padding: 0; margin: 0 } 这种，小伙伴们就应该减少设置，要不然页面的元素越多遍历匹配越久。</p><p>总结一下：</p><ul><li>避免使用通配符 * 等。</li><li>减少使用标签选择器，用类选择器或者标签选择器替代，例如 span 替换为 .span。</li><li>减少嵌套匹配，例如 #ul li a。</li></ul><h3 id="10-3-优化-CSS-加载问题"><a href="#10-3-优化-CSS-加载问题" class="headerlink" title="10.3 优化 - CSS 加载问题"></a>10.3 优化 - CSS 加载问题</h3><p>为了避免 HTML 解析完毕，但是 CSS 没有解析完毕，从而导致页面直接 “裸奔” 在用户面前的问题，浏览器在处理 CSS 规则树的时候，不会渲染任何已处理的内容。</p><p>所以很多时候，我们会让网页尽早处理 CSS，即在 head 标签中启用 link 或者启用 CDN 实现静态资源加载速度的优化。</p><h3 id="10-4-优化-JS-加载问题"><a href="#10-4-优化-JS-加载问题" class="headerlink" title="10.4 优化 - JS 加载问题"></a>10.4 优化 - JS 加载问题</h3><p>在上面的加载过程中我们并没有提到 JS，实际上 JS 会对 DOM 和 CSSDOM 进行修改，因此 JS 的执行会阻止 CSS 规则树的解析，有时候还会阻塞 DOM。</p><p>实际上，当 HTML 解析器遇上 script 标签时，它会暂停解析过程，将控制器交给 JS 引擎。</p><p>如果是内部的 JS 代码，它会直接执行，但是如果是 src 引入的，还要先获取脚本，再进行执行。</p><p>等 JS 引擎执行完毕后，再交接给渲染引擎，继续 HTML 树和 CSS 规则树的构建。</p><p>这样一来一回交接，而且有时候 JS 执行过多还会卡慢，进而导致页面渲染变慢。</p><p>所以我们可以通过 async 异步加载完 JS 脚本，再执行里面内容；或者通过 defer 等整个文档解析完毕后，再执行这个 JS 文件。</p><p>如果 JS 和 DOM 元素或者其他 JS 代码之间的依赖不强的时候，使用 async。</p><p>如果 JS 依赖于 DOM 元素和其他 JS 的执行结果，那就使用 defer。</p><h3 id="10-5-优化-DOM-渲染问题"><a href="#10-5-优化-DOM-渲染问题" class="headerlink" title="10.5 优化 - DOM 渲染问题"></a>10.5 优化 - DOM 渲染问题</h3><p>当使用 JS 去操作 DOM 的时候，实际上是 JS 引擎和渲染引擎之间的沟通，这个沟通的过程要开销的。</p><p>每操作一次 DOM 就收费一次，多了页面就卡起来咯。</p><p>同时，操作 DOM 的时候修改了尺寸等元素，还会引起回流和重绘。</p><ul><li><strong>回流（reflow）</strong>：又叫重排（layout）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。</li><li><strong>重绘（repaint）</strong>：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此损耗较少。</li></ul><p>详细可看<a href="https://ruimintan.github.io/posts/3d62f822.html">浏览器的回流与重绘</a></p><p><strong>回流必定重绘，重绘不一定回流</strong>。<br>因此，我们操作 DOM 的时候，可以这么优化：</p><ol><li>【CSS】使用 visibility 替换 display</li><li>【CSS】避免 table 布局。对于 Render Tree 的计算通常只需要遍历一次就可以完成，但是 table 布局需要计算多次，通常要花 3 倍于等同元素的时间，因此要避免。</li><li>【JS】避免频繁做 width、height 等会触发回流的操作。</li><li>【JS】操作 DOM 的时候，如果是添加 DOM 节点，可以将所有节点都在 JS 中操作完毕，再进行渲染（一次性）</li></ol><h3 id="十一、预加载页面资源"><a href="#十一、预加载页面资源" class="headerlink" title="十一、预加载页面资源"></a>十一、预加载页面资源</h3><p>preload 提供了一种声明式的命令，让浏览器提前加载指定资源（加载后并不执行），在需要执行的时候再执行。</p><p>提供的好处主要是：</p><ul><li>将加载和执行分离开，可不阻塞渲染和 document 的 onload 事件</li><li>提前加载指定资源，不再出现依赖的 font 字体隔了一段时间才刷出</li></ul><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 使用 link 标签静态标记需要预加载的资源 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/path/to/style.css<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>style<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 或使用脚本动态创建一个 link 标签后插入到 head 头部 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token keyword">const</span> link <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'link'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  link<span class="token punctuation">.</span>rel <span class="token operator">=</span> <span class="token string">'preload'</span><span class="token punctuation">;</span>  link<span class="token punctuation">.</span><span class="token keyword">as</span> <span class="token operator">=</span> <span class="token string">'style'</span><span class="token punctuation">;</span>  link<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">'/path/to/style.css'</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在不支持 preload 的浏览器环境中，会忽略对应的 link 标签。</p><p>区分 preload 和 prefetch：</p><ul><li>preload：告诉浏览器页面必定需要的资源，浏览器一定会加载这些资源。</li><li>prefetch：告诉浏览器页面可能需要的资源，浏览器不一定会加载这些资源。</li></ul><p>当然，开发中需要注意：</p><ul><li>避免滥用 preload</li><li>避免混用 preload 和 prefetch</li><li>避免错用 preload 加载跨域资源</li></ul><h2 id="十二、长列表"><a href="#十二、长列表" class="headerlink" title="十二、长列表"></a>十二、长列表</h2><h3 id="12-1-懒加载"><a href="#12-1-懒加载" class="headerlink" title="12.1 懒加载"></a>12.1 懒加载</h3><p>懒加载实现思路：</p><ul><li>div 通过背景图片设置为 none，起到占位的作用。</li><li>出现在可视区域的时候，div 填写有效 URL。</li></ul><p>还有其他方法，诸如：</p><ul><li>img 标签自带的 loading 属性</li><li>InsectionObserver</li><li>骨架屏</li></ul><h3 id="12-2-可视区域渲染"><a href="#12-2-可视区域渲染" class="headerlink" title="12.2 可视区域渲染"></a>12.2 可视区域渲染</h3><p>无限滚动在移动端很常见，但是可见区域渲染并不常见，主要是因为 IOS 上 UIWebView 的 onscroll 并不能实时触发。</p><p>实现可见区域渲染的思路：</p><ol><li>计算当前可见区域起始数据的 startIndex</li><li>计算当前可见区域结束数据的 endIndex</li><li>计算当前可见区域的数据，并渲染到页面中</li><li>计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset，并设置到列表上</li></ol><h2 id="十三、性能监控"><a href="#十三、性能监控" class="headerlink" title="十三、性能监控"></a>十三、性能监控</h2><ol><li>Chrome 工具 Performance</li><li>Chrome 插件 Page Speed</li><li>自动化工具 Lighthouse<ul><li>Chrome 拓展安装</li><li>npm i lighthouse -g、lighthouse <a href="https://www.baidu.com/">https://www.baidu.com</a></li><li>Chrome 有基于 LightHouse 的 Audits 面板</li></ul></li></ol><h2 id="十四、更多文章"><a href="#十四、更多文章" class="headerlink" title="十四、更多文章"></a>十四、更多文章</h2><ol><li><p><a href="https://juejin.cn/post/6844903655330562062">网站性能优化实战——从12.67s到1.06s的故事</a> 【阅读建议：30min】</p></li><li><p><a href="https://juejin.cn/post/6844903614138286094">懒加载和预加载</a>【阅读建议：10min】</p></li><li><p><a href="https://juejin.cn/post/6844903559599751175">现代化懒加载的方式</a>【阅读建议：5min】</p></li><li><p><a href="https://github.com/ljianshu/Blog/issues/9">页面性能优化办法有哪些？</a>【阅读建议：15min】</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的垃圾回收和内存泄漏</title>
      <link href="/posts/7aead763.html"/>
      <url>/posts/7aead763.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存。所谓的内存泄漏简单来说是不再用到的内存，没有及时释放。为了更好避免内存泄漏，我们先介绍Javascript垃圾回收机制。</p><p>在C与C++等语言中，开发人员可以直接控制内存的申请和回收。但是在Java、C#、JavaScript语言中，变量的内存空间的申请和释放都由程序自己处理，开发人员不需要关心。也就是说Javascript具有自动垃圾回收机制(Garbage Collecation)。</p><h2 id="一、内存回收"><a href="#一、内存回收" class="headerlink" title="一、内存回收"></a>一、内存回收</h2><p>JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。</p><ul><li>局部变量和全局变量的销毁<ul><li>局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。</li><li>全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量<strong>避免</strong>使用全局变量。</li></ul></li><li>以Google的V8引擎为例，V8引擎中所有的JS对象都是通过<strong>堆</strong>来进行内存分配的<ul><li>初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。</li><li>继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。</li></ul></li><li>V8引擎对堆内存中的JS对象进行<strong>分代管理</strong><ul><li>新生代：存活周期较短的JS对象，如临时变量、字符串等。</li><li>老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</li></ul></li></ul><p><strong>垃圾回收的必要性：</strong></p><blockquote><p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</p></blockquote><p>JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p><blockquote><p>var a = “浪里行舟”;<br>var b = “前端工匠”;<br>var a = b; //重写a</p></blockquote><p>这段代码运行之后，“浪里行舟”这个字符串失去了引用（之前是被a引用），系统检测到这个事实之后，就会释放该字符串的存储空间以便这些空间可以被再利用。</p><h2 id="二、垃圾回收算法"><a href="#二、垃圾回收算法" class="headerlink" title="二、垃圾回收算法"></a>二、垃圾回收算法</h2><p>对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。</p><ul><li>引用计数（现代浏览器不再使用）</li><li>标记清除（常用）</li></ul><h3 id="2-1-引用计数"><a href="#2-1-引用计数" class="headerlink" title="2.1 引用计数"></a>2.1 引用计数</h3><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的<strong>引用</strong>。如果没有其他对象指向它了，说明该对象已经不再需要了。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 创建一个对象person，他有两个指向属性age和name的引用</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>    age<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>    name<span class="token punctuation">:</span> <span class="token string">'aaaa'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收</span><span class="token keyword">var</span> p <span class="token operator">=</span> person<span class="token punctuation">;</span> person <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收</span>p <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//原person对象已经没有引用，很快会被回收</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引用计数有一个致命的问题，那就是<strong>循环引用</strong></p><p>如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">cycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    o1<span class="token punctuation">.</span>a <span class="token operator">=</span> o2<span class="token punctuation">;</span>    o2<span class="token punctuation">.</span>a <span class="token operator">=</span> o1<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token string">"cycle reference!"</span><span class="token punctuation">}</span><span class="token function">cycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器<strong>不再使用</strong>这个算法。</p><p>但是IE依旧使用。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>div<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的写法很常见，但是上面的例子就是一个循环引用。</p><p>变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。</p><h3 id="2-2-标记清除（常用）"><a href="#2-2-标记清除（常用）" class="headerlink" title="2.2 标记清除（常用）"></a>2.2 标记清除（常用）</h3><p>标记清除算法将“不再使用的对象”定义为“<strong>无法到达的对象</strong>”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，<strong>保留</strong>。那些从根部出发无法触及到的对象被标记为<strong>不再使用</strong>，稍后进行回收。</p><p>无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。</p><p>所以上面的例子就可以正确被垃圾回收处理了。</p><p>所以现在对于主流浏览器来说，只需要切断需要回收的对象与根部的联系。最常见的内存泄露一般都与DOM元素绑定有关：</p><pre class="line-numbers language-js"><code class="language-js">email<span class="token punctuation">.</span>message <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>“div”<span class="token punctuation">)</span><span class="token punctuation">;</span>displayList<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>email<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 稍后从displayList中清除DOM元素</span>displayList<span class="token punctuation">.</span><span class="token function">removeAllChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中。</p><p><strong>标记清除 （Mark-and-sweep）</strong>，算法由以下几步组成：</p><ul><li><p>1、垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；</p></li><li><p>2、所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。</p></li><li><p>3、所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。</p></li></ul><p>现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。</p><h2 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a>三、内存泄漏</h2><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）</p><h3 id="3-1-四种常见的JS内存泄漏"><a href="#3-1-四种常见的JS内存泄漏" class="headerlink" title="3.1 四种常见的JS内存泄漏"></a>3.1 四种常见的JS内存泄漏</h3><p><strong>划重点</strong> 这是个考点</p><h4 id="1-意外的全局变量"><a href="#1-意外的全局变量" class="headerlink" title="(1) 意外的全局变量"></a>(1) 意外的全局变量</h4><p>未定义的变量会在全局对象创建一个新变量，如下。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    bar <span class="token operator">=</span> <span class="token string">"this is a hidden global variable"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    window<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">"this is an explicit global variable"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另一个意外的全局变量可能由 this 创建。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>variable <span class="token operator">=</span> <span class="token string">"potential accidental global"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Foo 调用自己，this 指向了全局对象（window）</span><span class="token comment" spellcheck="true">// 而不是 undefined</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解决方法：</strong></p><p>在 JavaScript 文件头部加上 ‘use strict’，使用严格模式避免意外的全局变量，此时<strong>上例中的this指向undefined</strong>。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。</p><h4 id="2-被遗忘的计时器或回调函数"><a href="#2-被遗忘的计时器或回调函数" class="headerlink" title="(2) 被遗忘的计时器或回调函数"></a>(2) 被遗忘的计时器或回调函数</h4><p>计时器setInterval代码很常见</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> someResource <span class="token operator">=</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'Node'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 处理 node 和 someResource</span>        node<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>someResource<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    element<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'text'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。</p><p>但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用 removeEventListener 了。</p><h4 id="3-脱离-DOM-的引用"><a href="#3-脱离-DOM-的引用" class="headerlink" title="(3) 脱离 DOM 的引用"></a>(3) 脱离 DOM 的引用</h4><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。那么将来需要把两个引用都清除。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> elements <span class="token operator">=</span> <span class="token punctuation">{</span>    button<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    image<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'image'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    text<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'text'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    image<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://some.url/image'</span><span class="token punctuation">;</span>    button<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 更多逻辑</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">removeButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 按钮是 body 的后代元素</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 此时，仍旧存在一个全局的 #button 的引用</span>    <span class="token comment" spellcheck="true">// elements 字典。button 元素仍旧在内存中，不能被 GC 回收。</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果代码中保存了表格某一个  &lt;td&gt;  的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的  &lt;td&gt;  以外的其它节点。实际情况并非如此：此  &lt;td&gt;  是表格的子节点，子元素与父元素是引用关系。由于代码保留了  &lt;td&gt;  的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。</p><h4 id="4-闭包"><a href="#4-闭包" class="headerlink" title="(4) 闭包"></a>(4) 闭包</h4><p>闭包的关键是匿名函数可以访问父级作用域的变量。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> theThing <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">var</span> replaceThing <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> originalThing <span class="token operator">=</span> theThing<span class="token punctuation">;</span>  <span class="token keyword">var</span> unused <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>originalThing<span class="token punctuation">)</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>      theThing <span class="token operator">=</span> <span class="token punctuation">{</span>    longStr<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    someMethod<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>someMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">setInterval</span><span class="token punctuation">(</span>replaceThing<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。</p><p><strong>解决方法：</strong></p><p>在 replaceThing 的最后添加 originalThing = null 。</p><h3 id="3-2-内存泄漏识别方法"><a href="#3-2-内存泄漏识别方法" class="headerlink" title="3.2 内存泄漏识别方法"></a>3.2 内存泄漏识别方法</h3><h4 id="1-、浏览器方法"><a href="#1-、浏览器方法" class="headerlink" title="(1)、浏览器方法"></a>(1)、浏览器方法</h4><ol><li>打开开发者工具，选择 Memory</li><li>在右侧的Select profiling type字段里面勾选 timeline</li><li>点击左上角的录制按钮。</li><li>在页面上进行各种操作，模拟用户的使用情况。</li><li>一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。</li></ol><h4 id="2-、命令行方法"><a href="#2-、命令行方法" class="headerlink" title="(2)、命令行方法"></a>(2)、命令行方法</h4><p>使用 Node 提供的 process.memoryUsage 方法。</p><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出</span><span class="token punctuation">{</span>   rss<span class="token punctuation">:</span> <span class="token number">27709440</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// resident set size，所有内存占用，包括指令区和堆栈</span>  heapTotal<span class="token punctuation">:</span> <span class="token number">5685248</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// "堆"占用的内存，包括用到的和没用到的</span>  heapUsed<span class="token punctuation">:</span> <span class="token number">3449392</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 用到的堆的部分</span>  external<span class="token punctuation">:</span> <span class="token number">8772</span>         <span class="token comment" spellcheck="true">// V8 引擎内部的 C++ 对象占用的内存</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断内存泄漏，以heapUsed字段为准。</p><h3 id="3-3-避免内存泄漏的一些方式"><a href="#3-3-避免内存泄漏的一些方式" class="headerlink" title="3.3 避免内存泄漏的一些方式"></a>3.3 避免内存泄漏的一些方式</h3><ul><li>减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收</li><li>注意程序逻辑，避免“死循环”之类的</li><li>避免创建过多的对象<br>总而言之需要遵循一条<strong>原则：不用了的东西要及时归还</strong></li></ul><h2 id="四、垃圾回收的使用场景优化"><a href="#四、垃圾回收的使用场景优化" class="headerlink" title="四、垃圾回收的使用场景优化"></a>四、垃圾回收的使用场景优化</h2><h3 id="1-数组array优化"><a href="#1-数组array优化" class="headerlink" title="1.数组array优化"></a>1.数组array优化</h3><p>将[]赋值给一个数组对象，是清空数组的捷径(例如： arr = [];),但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'浪里行舟'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true">// 可以直接让数字清空，而且数组类型不变。</span><span class="token comment" spellcheck="true">// arr = []; 虽然让a变量成一个空数组,但是在堆上重新申请了一个空数组对象。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-对象尽量复用"><a href="#2-对象尽量复用" class="headerlink" title="2. 对象尽量复用"></a>2. 对象尽量复用</h3><p>对象尽量复用，尤其是在循环等地方出现创建新对象，能复用就复用。不用的对象，尽可能设置为null，尽快被垃圾回收掉。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 每次循环都会创建一个新对象。</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// var t = {};// 每次循环都会创建一个新对象。</span>  t<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">19</span>  t<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'123'</span>  t<span class="token punctuation">.</span>index <span class="token operator">=</span> i  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">}</span>t <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment" spellcheck="true">//对象如果已经不用了，那就立即设置为null；等待垃圾回收。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-在循环中的函数表达式，能复用最好放到循环外面。"><a href="#3-在循环中的函数表达式，能复用最好放到循环外面。" class="headerlink" title="3.在循环中的函数表达式，能复用最好放到循环外面。"></a>3.在循环中的函数表达式，能复用最好放到循环外面。</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在循环中最好也别使用函数表达式。</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建了10次  函数对象。</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">t</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 推荐用法</span><span class="token keyword">function</span> <span class="token function">t</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">t</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">}</span>t <span class="token operator">=</span> <span class="token keyword">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://muyiy.cn/blog/1/1.4.html#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6">木易杨前端进阶</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从输入URL到页面呈现</title>
      <link href="/posts/d2ae3efb.html"/>
      <url>/posts/d2ae3efb.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>打开浏览器从输入网址到网页呈现在大家面前，背后到底发生了什么？经历怎么样的一个过程？先给大家来张总体流程图，具体步骤请看下文分解！</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/fdf181461044c912aff2718780c652b7690fc4541d71d38ab5db3ee9bb0ef15b/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d333334333463346233653262383030642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="从URL输入到页面展现"></p><p>总体来说分为以下几个过程:</p><ul><li>DNS 解析:将域名解析成 IP 地址</li><li>TCP 连接：TCP 三次握手</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>断开连接：TCP 四次挥手</li></ul><h2 id="一、URL-到底是啥"><a href="#一、URL-到底是啥" class="headerlink" title="一、URL 到底是啥"></a>一、URL 到底是啥</h2><p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。<br>比如 <a href="http://www.w3school.com.cn/html/index.asp">http://www.w3school.com.cn/html/index.asp</a>，遵守以下的语法规则：</p><p><strong>scheme://host.domain:port/path/filename</strong></p><p>各部分解释如下：<br>scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。<br>host - 定义域主机（http 的默认主机是 www）<br>domain - 定义因特网<strong>域名</strong>，比如 w3school.com.cn<br>port - 定义主机上的端口号（http 的默认端口号是 80）<br>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。<br>filename - 定义文档/资源的名称</p><h2 id="二、域名解析（DNS）"><a href="#二、域名解析（DNS）" class="headerlink" title="二、域名解析（DNS）"></a>二、域名解析（DNS）</h2><p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。大家这里或许会有个疑问—-计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如 <a href="http://www.hackr.jp.那怎么不一开始就赋予个/">www.hackr.jp。那怎么不一开始就赋予个</a> IP 地址？这样就可以省去解析麻烦。我们先来了解下什么是 IP 地址</p><h3 id="1-IP-地址"><a href="#1-IP-地址" class="headerlink" title="1.IP 地址"></a>1.IP 地址</h3><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。</p><p><strong>域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址。</strong>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。<strong>因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。</strong></p><h3 id="2-什么是域名解析"><a href="#2-什么是域名解析" class="headerlink" title="2.什么是域名解析"></a>2.什么是域名解析</h3><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。<strong>DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</strong></p><blockquote><p>例如 baidu.com  220.114.23.56（服务器外网IP地址）80（服务器端口号）</p></blockquote><h3 id="3-浏览器如何通过域名去查询-URL-对应的-IP-呢"><a href="#3-浏览器如何通过域名去查询-URL-对应的-IP-呢" class="headerlink" title="3. 浏览器如何通过域名去查询 URL 对应的 IP 呢"></a>3. 浏览器如何通过域名去查询 URL 对应的 IP 呢</h3><ul><li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li><li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li><li>路由缓存：路由器也有 DNS 缓存。</li><li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li><li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/35921ee58f0ed04c524990104c84b04e8e4d1a030db0ec1994cd314e5c0c9044/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d376133393962376633383665383938342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="DNS解析流程"></p><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p><strong>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/b1765e49d29d49d51d576eef7c66ba048e71753f587e05d90bc4213c0696633d/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d613931326563616630343066313831642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"></p><h2 id="三、TCP-三次握手"><a href="#三、TCP-三次握手" class="headerlink" title="三、TCP 三次握手"></a>三、TCP 三次握手</h2><p><strong>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/26fd6920216ddfa97983e806c4c3bdee4969b0d384245ebdcdefa7e87b8df331/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d646163616137613937346265613038313f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"></p><p><strong>1.TCP 三次握手的过程如下：</strong></p><ul><li><p><strong>客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口</strong>（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</p></li><li><p><strong>服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息</strong>（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</p></li><li><p><strong>客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”</strong>（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</p></li></ul><p><strong>2.为啥需要三次握手</strong><br>谢希仁著《计算机网络》中讲“三次握手”的目的是“<strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</strong>”。</p><h2 id="四、发送-HTTP-请求"><a href="#四、发送-HTTP-请求" class="headerlink" title="四、发送 HTTP 请求"></a>四、发送 HTTP 请求</h2><p><strong>TCP 三次握手结束后，开始发送 HTTP 请求报文。</strong><br>请求报文由请求行（request line）、请求头（header）、请求体三个部分组成,如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/925dad6c8a90cdeb8bff598bad1268f0b8c73de7f6e58bfdc5783015de24ef25/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d353136643833333766353834616663372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"></p><p><strong>1.请求行包含请求方法、URL、协议版本</strong></p><ul><li>请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</li><li>URL 即请求地址，由 &lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 组成</li><li>协议版本即 http 版本号</li></ul><blockquote><p>POST  /chapter17/user.html HTTP/1.1</p></blockquote><p>以上代码中“POST”代表请求方法，“/chapter17/user.html”表示 URL，“HTTP/1.1”代表协议和协议的版本。现在比较流行的是 Http1.1 版本</p><p><strong>2.请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。</strong><br>请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：<strong>Host，表示主机名，虚拟主机；Connection,HTTP/1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent，请求发出者，兼容性以及定制化需求。</strong></p><p><strong>3.请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。</strong></p><blockquote><p>name=tom&amp;password=1234&amp;realName=tomson</p></blockquote><p>上面代码，承载着 name、password、realName 三个请求参数。</p><h2 id="五、服务器处理请求并返回-HTTP-报文"><a href="#五、服务器处理请求并返回-HTTP-报文" class="headerlink" title="五、服务器处理请求并返回 HTTP 报文"></a>五、服务器处理请求并返回 HTTP 报文</h2><h3 id="1-服务器"><a href="#1-服务器" class="headerlink" title="1. 服务器"></a>1. 服务器</h3><p>服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。</p><p><strong>web server 担任管控的角色</strong>，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/2a3f031b85b2335c7a2d690f533f3101a3509e6e7086da327df39fd44d10f439/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d616264376634326331646463386635332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="服务器和客户端区别"></p><h3 id="2-MVC-后台处理阶段"><a href="#2-MVC-后台处理阶段" class="headerlink" title="2.MVC 后台处理阶段"></a>2.MVC 后台处理阶段</h3><p>后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。<br>MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）– 视图（view）–控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/bde12dd5baaa7d6b8dbc0df2a0339357e60ac49a3236469210e91fcc7e88e103/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d373464633137326635303765633235642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="MVC架构"></p><ul><li>1、视图（view）</li></ul><p><strong>它是提供给用户的操作界面，是程序的外壳。</strong></p><ul><li>2、模型（model）</li></ul><p><strong>模型主要负责数据交互。</strong>在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。</p><ul><li>3、控制器（controller）</li></ul><p><strong>它负责根据用户从”视图层”输入的指令，选取”模型层”中的数据，然后对其进行相应的操作，产生最终结果。</strong>控制器属于管理者角色，从视图接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。<br>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。<br>至于这一阶段发生什么？简而言之，<strong>首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。</strong></p><h3 id="3-http-响应报文"><a href="#3-http-响应报文" class="headerlink" title="3.http 响应报文"></a>3.http 响应报文</h3><p>响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/3d9015adfd08a645e8512796c3b22d94a955f34187c31f63e2f1df544d92bbaf/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d666637626663306163616638353963642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"></p><p>(1) 响应行包含：协议版本，状态码，状态码描述</p><p>状态码规则如下：<br>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求。</p><p>(2) 响应头部包含响应报文的附加信息，由 名/值 对组成</p><p>(3) 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据</p><h2 id="六、浏览器解析渲染页面"><a href="#六、浏览器解析渲染页面" class="headerlink" title="六、浏览器解析渲染页面"></a>六、浏览器解析渲染页面</h2><p>浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/49a501ae060c7928e74ce16f25894ab00aef7f96c417eb1081e3b2e25be99c5d/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d653035386462386539306434303736302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"></p><p>浏览器解析渲染页面分为一下五个步骤：</p><ul><li>根据 HTML 解析出 DOM 树</li><li>根据 CSS 解析生成 CSS 规则树</li><li>结合 DOM 树和 CSS 规则树，生成渲染树</li><li>根据渲染树计算每一个节点的信息</li><li>根据计算好的信息绘制页面</li></ul><p><strong>1.根据 HTML 解析 DOM 树</strong></p><ul><li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li><li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li></ul><p><strong>2.根据 CSS 解析生成 CSS 规则树</strong></p><ul><li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li><li>浏览器在 CSS 规则树生成之前不会进行渲染。</li></ul><p><strong>3.结合 DOM 树和 CSS 规则树，生成渲染树</strong></p><ul><li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li><li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li></ul><p><strong>4.根据渲染树计算每一个节点的信息（布局）</strong></p><ul><li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li><li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li></ul><p><strong>5.根据计算好的信息绘制页面</strong></p><ul><li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li><li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li><li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li></ul><h2 id="七、断开连接"><a href="#七、断开连接" class="headerlink" title="七、断开连接"></a>七、断开连接</h2><p><strong>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/a07bdd2ccc16322e28236bfca715a1476e685554086722de01c99e08a41b4238/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d353631323264353831316665663062312e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"></p><ul><li><strong>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。</strong>(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li><li><strong>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态</strong>。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li><li><strong>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态</strong>。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li><li><strong>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭</strong>。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解浏览器缓存机制</title>
      <link href="/posts/260ad1cb.html"/>
      <url>/posts/260ad1cb.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。</p><p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</p><p>接下来的内容中我们将通过缓存位置、缓存策略以及实际场景应用缓存策略来探讨浏览器缓存机制。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/27c02292dc435dbdc44ea399dad74b3a6a5aa00e3e035c2023107c2e8429d73c/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f352f313638316332316530343535326637373f773d3232313326683d39343826663d706e6726733d333131313733"></p><h2 id="二、缓存位置"><a href="#二、缓存位置" class="headerlink" title="二、缓存位置"></a>二、缓存位置</h2><p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。</p><ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><h3 id="1-Service-Worker"><a href="#1-Service-Worker" class="headerlink" title="1.Service Worker"></a>1.Service Worker</h3><p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。<strong>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</strong></p><p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p><p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p><h3 id="2-Memory-Cache"><a href="#2-Memory-Cache" class="headerlink" title="2.Memory Cache"></a>2.Memory Cache</h3><p>Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 <strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</strong></p><p><strong>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</strong><br>这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。</p><p>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</p><p>内存缓存中有一块重要的缓存资源是preloader相关指令（例如 &lt;link rel=”prefetch”&gt; ）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。</p><p>需要注意的事情是，<strong>内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。</strong></p><h3 id="3-Disk-Cache"><a href="#3-Disk-Cache" class="headerlink" title="3.Disk Cache"></a>3.Disk Cache</h3><p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，<strong>比之 Memory Cache 胜在容量和存储时效性上。</strong></p><p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。</p><p><strong>浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？</strong><br>关于这点，网上说法不一，不过以下观点比较靠得住：</p><ul><li>对于大文件来说，大概率是不存储在内存中的，反之优先</li><li>当前系统内存使用率高的话，文件优先存储进硬盘</li></ul><h3 id="4-Push-Cache"><a href="#4-Push-Cache" class="headerlink" title="4.Push Cache"></a>4.Push Cache</h3><p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，</strong>在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><p>Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 <a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/">HTTP/2 push is tougher than I thought</a> 这篇文章，文章中的几个结论：</p><ul><li>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差</li><li>可以推送 no-cache 和 no-store 的资源</li><li>一旦连接被关闭，Push Cache 就被释放</li><li>多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</li><li>Push Cache 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li>你可以给其他域名推送资源</li></ul><p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p><p>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，<strong>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。</strong></p><h2 id="三、缓存过程分析"><a href="#三、缓存过程分析" class="headerlink" title="三、缓存过程分析"></a>三、缓存过程分析</h2><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求，<strong>那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？</strong>浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，<strong>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的</strong>。具体过程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/b801018b95a8ee1c5c3d41b302dee9b320f12920ab8172f27ee3a8634d5b2989/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f32302f313633376430626264363935653735313f773d36373026683d35313226663d706e6726733d313635313332" alt="第一次发起HTTP请求"></p><p>由上图我们可以知道：</p><ul><li><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p></li><li><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p></li></ul><p>以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。</p><h2 id="四、强缓存"><a href="#四、强缓存" class="headerlink" title="四、强缓存"></a>四、强缓存</h2><p><strong>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</strong></p><h3 id="1-Expires"><a href="#1-Expires" class="headerlink" title="1.Expires"></a>1.Expires</h3><p><strong>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。</strong>也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p><strong>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</strong>Expires: Wed, 22 Oct 2018 08:41:00 GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。</p><h3 id="2-Cache-Control"><a href="#2-Cache-Control" class="headerlink" title="2.Cache-Control"></a>2.Cache-Control</h3><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>public</td><td>表示响应可以被客户端和代理服务器缓存</td></tr><tr><td>private</td><td>表示响应只可以被客户端缓存</td></tr><tr><td>max-age=30</td><td>缓存30秒后就过期，需要重新请求</td></tr><tr><td>s-maxage=30</td><td>覆盖max-age，作用一样，只在代理服务器中生效</td></tr><tr><td>no-store</td><td>不缓存任何响应</td></tr><tr><td>no-cache</td><td>资源被缓存，但是立即失效，下次会发起请求验证资源是否过期</td></tr><tr><td>max-state=30</td><td>30秒内，即使缓存过期，也使用该缓存</td></tr><tr><td>min-fresh=30</td><td>希望在30秒内获取最新的响应</td></tr></tbody></table><p><strong>public：所有内容都将被缓存（客户端和代理服务器都可缓存）。</strong>具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。</p><p><strong>private：所有内容只有客户端可以缓存，</strong>Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。</p><p><strong>no-cache：</strong>客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。<strong>需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</strong></p><p><strong>no-store：</strong>所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p><p><strong>max-age：</strong>max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效</p><p><strong>s-maxage</strong>（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。<strong>s-maxage的优先级高于max-age。</strong>如果存在s-maxage，则会覆盖掉max-age和Expires header。</p><p><strong>max-stale：</strong>能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。</p><p><strong>min-fresh：</strong>能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/d60f52d782ef5f2a8f83b98886a92c6b8fb7d4067dc8d48fc27ee9e00d0b914b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f32302f313633376430626264366461313134663f773d38323026683d37333926663d706e6726733d313033333139" alt="cache-control"></p><p>从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。</p><h3 id="3-Expires和Cache-Control两者对比"><a href="#3-Expires和Cache-Control两者对比" class="headerlink" title="3.Expires和Cache-Control两者对比"></a>3.Expires和Cache-Control两者对比</h3><p>其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，<strong>两者同时存在的话，Cache-Control优先级高于Expires；</strong>在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</p><p>强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，<strong>那我们如何获知服务器端内容是否已经发生了更新呢？</strong>此时我们需要用到协商缓存策略。</p><h2 id="五、协商缓存"><a href="#五、协商缓存" class="headerlink" title="五、协商缓存"></a>五、协商缓存</h2><p><strong>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</strong></p><ul><li>协商缓存生效，返回304和Not Modified</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/da4f384734af2031f7431e5ff32da5a9750ff7fbfba2a2d74e1c24b4b9128abd/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f32302f313633376430626264366364373032643f773d37303926683d35333926663d706e6726733d313736303036" alt="协商缓存生效"></p><ul><li>协商缓存失效，返回200和请求结果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/f23360efc03467281385840e2a968d6fc6783ebba102c1c1645ed6f562530c74/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f32302f313633376430626264613936616336303f773d36363626683d35313826663d706e6726733d313730313532" alt="协商缓存失效"></p><p>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。</p><h3 id="1-Last-Modified和If-Modified-Since"><a href="#1-Last-Modified和If-Modified-Since" class="headerlink" title="1.Last-Modified和If-Modified-Since"></a>1.Last-Modified和If-Modified-Since</h3><p>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；</p><blockquote><p>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</p></blockquote><p>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/790cbd54866178b2c371acb1060661a772297c3709fbdce0a363fa1978389686/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f342f313638313437383262356533343637303f773d34333826683d33383026663d706e6726733d3539363438"></p><p><strong>但是 Last-Modified 存在一些弊端：</strong></p><ul><li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</li><li>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li></ul><p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和If-None-Match</p><h3 id="2-ETag和If-None-Match"><a href="#2-ETag和If-None-Match" class="headerlink" title="2.ETag和If-None-Match"></a>2.ETag和If-None-Match</h3><p><strong>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。</strong>浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/images/ETag.png" alt="ETag和If-None-Match"></p><h3 id="3-两者之间对比："><a href="#3-两者之间对比：" class="headerlink" title="3.两者之间对比："></a>3.两者之间对比：</h3><ul><li><p>首先在精确度上，Etag要优于Last-Modified。<br>Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</p></li><li><p>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</p></li><li><p>第三在优先级上，服务器校验优先考虑Etag</p></li></ul><h2 id="六、缓存机制"><a href="#六、缓存机制" class="headerlink" title="六、缓存机制"></a>六、缓存机制</h2><p><strong>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。</strong></p><p>具体流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/fae4b3be025ff274c5f04ba325fda5a7c17d04fc2e4edbac6182d041a4bb744e/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f342f313638313936346439363363356138363f773d35313926683d34363226663d706e6726733d313630373937" alt="缓存的机制"></p><p>看到这里，不知道你是否存在这样一个疑问:<strong>如果什么缓存策略都没设置，那么浏览器会怎么处理？</strong></p><p>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。</p><h2 id="七、实际场景应用缓存策略"><a href="#七、实际场景应用缓存策略" class="headerlink" title="七、实际场景应用缓存策略"></a>七、实际场景应用缓存策略</h2><h3 id="1-频繁变动的资源"><a href="#1-频繁变动的资源" class="headerlink" title="1.频繁变动的资源"></a>1.频繁变动的资源</h3><blockquote><p>Cache-Control: no-cache</p></blockquote><p>对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p><h3 id="2-不常变化的资源"><a href="#2-不常变化的资源" class="headerlink" title="2.不常变化的资源"></a>2.不常变化的资源</h3><blockquote><p>Cache-Control: max-age=31536000</p></blockquote><p>通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。<br>在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。</p><h2 id="八、用户行为对浏览器缓存的影响"><a href="#八、用户行为对浏览器缓存的影响" class="headerlink" title="八、用户行为对浏览器缓存的影响"></a>八、用户行为对浏览器缓存的影响</h2><p>所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：</p><ul><li>打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解浏览器存储</title>
      <link href="/posts/98839129.html"/>
      <url>/posts/98839129.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着移动网络的发展与演化，我们手机上现在除了有原生 App，还能跑“WebApp”——它即开即用，用完即走。一个优秀的 WebApp 甚至可以拥有和原生 App 媲美的功能和体验。WebApp 优异的性能表现，有一部分原因要归功于浏览器存储技术的提升。cookie存储数据的功能已经很难满足开发所需，逐渐被Web Storage、IndexedDB所取代，本文将介绍这几种存储方式的差异和优缺点。</p><h2 id="一、cookie"><a href="#一、cookie" class="headerlink" title="一、cookie"></a>一、cookie</h2><h3 id="1-cookie的来源"><a href="#1-cookie的来源" class="headerlink" title="1.cookie的来源"></a>1.cookie的来源</h3><p><strong>cookie 的本职工作并非本地存储，而是“维持状态”。</strong>因为HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了cookie。它就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取cookie中包含信息，借此维护用户跟服务器会话中的状态。</p><p>在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的cookie就行了。</p><h3 id="2-什么是cookie"><a href="#2-什么是cookie" class="headerlink" title="2.什么是cookie"></a>2.什么是cookie</h3><p>cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 <strong>cookie是服务端生成，客户端进行维护和存储，</strong>存储在内存或者磁盘中。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的Set-Cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。</p><p>简而言之，cookie 使基于无状态的HTTP协议记录稳定的状态信息成为了可能。</p><p>cookie 主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="3-cookie的原理及其构成"><a href="#3-cookie的原理及其构成" class="headerlink" title="3.cookie的原理及其构成"></a>3.cookie的原理及其构成</h3><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/757e4f5a9225e69d0438c00905926c88c242216b744c7f18bf703ce2bd861509/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f30393031363135343238323434623961613933643137393837383737376234617e74706c762d6b3375316662706663702d7a6f6f6d2d312e696d616765" alt="简单的HTTP请求过程"></p><p>第一次访问网站的时候，浏览器发出请求，服务器端生成 cookie在响应中通过Set-Cookie头部告知客户端(允许多个Set-Cookie头部传递多个值)，客户端得到 cookie后,后续请求都会自动将 cookie头部携带至请求中发送给服务器（见下面例子），另外，cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p><blockquote><p>// 一个HTTP响应：<br>HTTP/1.1 200 OK<br>Content-type: text/html<br>Set-Cookie: name=value<br>Other-header: other-header-value</p></blockquote><p>这个HTTP响应会设置一个名为”name”，值为”value”的cookie。名和值在发送时都会经过URL编码。浏览器会存储这些会话信息，并在之后的每个请求中都会通过HTTP头部cookie再将它们发回服务器，比如：</p><blockquote><p>GET /index.jsl HTTP/1.1<br>Cookie: name=value<br>Other-header: other-header-value</p></blockquote><p>cookie在浏览器中是由以下参数构成的：</p><ul><li>name：唯一标识cookie的名称。cookie名不区分大小写，因此myCookie和MyCookie是同一个名称。不过，实践中最好将cookie名当成区分大小写来对待，因为一些服务器软件可能这样对待它们。<strong>cookie名必须经过URL编码。</strong></li><li>value：存储在cookie里的字符串值。<strong>这个值必须经过URL编码。</strong></li><li>Domain：cookie有效的域。发送到这个域的所有请求都会包含对应的cookie。如果不指定，默认为文档来源（由协议、域名和端口共同定义），<strong>不包含子域名。</strong>如果指定了Domain，则一般包含子域名。因此，指定 Domain 比省略它的限制要少。但是，当子域需要共享有关用户的信息时，这可能会有所帮助。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如developer.mozilla.org）。</li><li>Path：请求URL中包含这个路径才会把cookie发送到服务器。</li></ul><blockquote><p>// 例如，设置 Path=/docs，则以下地址都会匹配：<br>/docs<br>/docs/Web/<br>/docs/Web/HTTP</p></blockquote><ul><li>Expires/Max-Age：设置cookie过期时间（Expires）或有效期（Max-Age）（即什么时间之后就不发送到服务器了）。<strong>简单名/值对形式的cookie只在当前会话期间存在，用户关闭浏览器就会丢失。</strong>如果想让cookie的生命周期超过单个浏览对话，那就指定Expires/Max-Age，<strong>max-age优先级高于expires。</strong></li><li>Secure：设置之后，<strong>只在使用SSL安全连接</strong>的情况下才会把cookie发送到服务器。例如，请求<a href="https://www.wrox.com/">https://www.wrox.com</a>会发送cookie，而请求<a href="http://www.wrox.com/">http://www.wrox.com</a>则不会。</li><li>HttpOnly：设置了 HttpOnly 属性的 cookie 不能使用 JavaScript 经由 Document.cookie 属性、XMLHttpRequest 和 Request APIs 进行访问，以防范跨站脚本攻击（XSS）。</li></ul><blockquote><p>HTTP/1.1 200 OK<br>Content-type: text/html<br>Set-Cookie: name=value; domain=.wrox.com; path=/; secure<br>Other-header: other-header-value</p></blockquote><p>这里创建的cookie对所有wrox.com的子域及该域中的所有页面有效（通过path=/指定）。不过，这个cookie只能在SSL连接上发送，因为设置了secure标志。</p><p>要知道，<strong>域、路径、过期时间和secure标志用于告诉浏览器什么情况下应该在请求中包含cookie。</strong>这些参数并不会随请求发送给服务器，<strong>实际发送的只有cookie的名/值对。</strong></p><h3 id="4-Javascript-中的cookie"><a href="#4-Javascript-中的cookie" class="headerlink" title="4.Javascript 中的cookie"></a>4.Javascript 中的cookie</h3><p>一般说来，cookie的生成方式主要有两种，一种是上文提到的在响应中通过Set-Cookie头部告知客户端；另外一种就是在JavaScript中可以通过document.cookie可以读写cookie，如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//读取浏览器中的cookie</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>cookie<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//写入cookie</span>document<span class="token punctuation">.</span>cookie<span class="token operator">=</span><span class="token string">'myname=langlixingzhou;path=/;domain=.baidu.com'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在JavaScript中处理cookie比较麻烦，因为接口过于简单，只有BOM的document.cookie属性。在设置值时，可以通过document.cookie属性设置新的cookie字符串。这个字符串在被解析后会添加到原有cookie中。设置document.cookie不会覆盖之前存在的任何cookie，除非设置了已有的cookie。要为创建的cookie指定额外的信息，只要像Set-Cookie头部一样直接在后面追加相同格式的字符串即可：</p><pre class="line-numbers language-js"><code class="language-js">document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token function">encodeURIComponent</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span>                  <span class="token function">encodeURIComponent</span><span class="token punctuation">(</span><span class="token string">"Nicholas"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"; domain=.wrox.com; path=/"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用encodeURIComponent()对名称和值进行编码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-cookie的缺陷"><a href="#5-cookie的缺陷" class="headerlink" title="5.cookie的缺陷"></a>5.cookie的缺陷</h3><ul><li><p>cookie 不够大<br>每个cookie的大小为4KB（<strong>名字和值都包含在这4KB之内</strong>），对于复杂的存储需求来说是不够用的。当 cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的cookie个数也是有限制的（一般来说不超过300个cookie）。</p></li><li><p>过多的 cookie 会带来巨大的性能浪费<br>cookie是与特定域绑定的。同一个域名下的所有请求，都会携带 cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 cookie 跑来跑去（关键是 cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。cookie 虽然小，但随着请求的叠加，这样的不必要的 cookie 带来的开销将是无法想象的。</p></li></ul><p>cookie是用来维护用户信息的，而域名(domain)下所有请求都会携带cookie，但对于静态文件的请求，携带cookie信息根本没有用，此时可以通过CDN（存储静态文件的）的域名和主站的域名分开来解决。</p><ul><li>由于在HTTP请求中的cookie是明文传递的，所以安全性成问题，除非用HTTPS。</li></ul><h3 id="6-cookie与安全"><a href="#6-cookie与安全" class="headerlink" title="6.cookie与安全"></a>6.cookie与安全</h3><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>value</td><td>如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</td></tr><tr><td>http-only</td><td>不能通过JS访问Cookie，减少XSS攻击</td></tr><tr><td>secure</td><td>只能在协议为HTTPS的请求中携带</td></tr><tr><td>same-site</td><td>规定浏览器不能再跨域请求中携带Cookie，减少CSRF攻击</td></tr></tbody></table><p>有两种方法可以确保 cookie 被安全发送，并且不会被意外的参与者或脚本访问：Secure 属性和HttpOnly 属性。</p><p>标记为 Secure 的 cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端，因此可以预防中间人攻击。但即便设置了 Secure 标记，<strong>敏感信息也不应该通过 cookie 传输，</strong>因为 cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它。</p><p>从 Chrome 52 和 Firefox 52 开始，不安全的站点（http:）无法使用cookie的 Secure 标记。</p><p>JavaScript  Document.cookie API 无法访问带有 HttpOnly 属性的cookie；此类 cookie 仅作用于服务器。例如，持久化服务器端会话的 cookie 不需要对 JavaScript 可用，而应具有 HttpOnly 属性。此预防措施有助于缓解跨站点脚本（XSS）攻击。</p><blockquote><p>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2019 07:28:00 GMT; Secure; HttpOnly</p></blockquote><p>对cookie的限制及其特性决定了cookie并不是存储大量数据的理想方式，让“专业的人做专业的事情”，Web Storage 出现了。</p><p>HTML5中新增了本地存储的解决方案—-Web Storage，这样有了Web Storage后，cookie能只做它应该做的事情了—— 作为客户端与服务器交互的通道，保持客户端状态。</p><h2 id="二、Web-Storage"><a href="#二、Web-Storage" class="headerlink" title="二、Web Storage"></a>二、Web Storage</h2><p>Web Storage的目的是解决通过客户端存储不需要频繁发送回服务器的数据时使用cookie的问题。Web Storage API包含了两个对象：localStorage和sessionStorage，<strong>本质上是映射字符串键和值的对象化。</strong>localStorage是永久存储机制，sessionStorage是跨会话的存储机制。这两种浏览器存储API提供了在浏览器中不受页面刷新影响而存储数据的两种方式。</p><h3 id="1、Storage-对象"><a href="#1、Storage-对象" class="headerlink" title="1、Storage 对象"></a>1、Storage 对象</h3><p>Window 对象的localStorage 和 sessionStorage 属性引用的是 Storage对象。Storage对象用于保存名/值对数据，直至存储空间上限（由浏览器决定）。一般来说，客户端数据的大小限制是按照每个源（协议、域和端口）来设置的，因此每个源有固定大小的数据存储空间。不同浏览器给localStorage和sessionStorage设置了不同的空间限制，但大多数会限制为每个源5MB。</p><p>Storage对象定义了如下方法：</p><ul><li>clear()：删除所有值；不在Firefox中实现。</li><li>getItem(name)：取得给定name的值。</li><li>key(index)：取得给定数值位置的名称。</li><li>removeItem(name)：删除给定name的名/值对。</li><li>setItem(name, value)：设置给定name的值。</li></ul><p><strong>Storage 对象中的键值对总是以字符串的形式存储，</strong>这意味着数值类型会自动转化为字符串类型。</p><h3 id="2、sessionStorage"><a href="#2、sessionStorage" class="headerlink" title="2、sessionStorage"></a>2、sessionStorage</h3><p>sessionStorage对象只存储会话数据，这意味着数据只会存储到浏览器关闭。这跟浏览器关闭时会消失的会话cookie类似。存储在sessionStorage中的数据不受页面刷新影响，可以在浏览器崩溃并重启后恢复（取决于浏览器，Firefox和WebKit支持，IE不支持）。</p><p>sessionStorage 特别应该注意一点就是，<strong>即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 数据便无法共享。</strong></p><p>localStorage 与 sessionStorage 在 API 方面无异，这里我们以 sessionStorage 为例：</p><ul><li>存储数据：setItem()<br>sessionStorage.setItem(‘user_name’, ‘juejin’)</li><li>读取数据： getItem()<br>sessionStorage.getItem(‘user_name’)</li><li>删除某一键名对应的数据： removeItem()<br>sessionStorage.removeItem(‘user_name’)</li><li>清空数据记录：clear()<br>sessionStorage.clear()</li></ul><p>虽然Web Storage存储数据会带来诸多便利，但实际开发中使用它也有不便之处：</p><ul><li>sessionStorage本身有API,但是只是简单的 key/value形式</li><li>sessionStorage只存储字符串,需要转换成json对象</li></ul><p>基于上面两点，开发过程中会对它进行封装后再调用：</p><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">// 碍于文章篇幅，并未将完整代码展示出来</span> <span class="token comment" spellcheck="true">// 想要获取完整的代码，可以加wx:qqlcx55</span> <span class="token comment" spellcheck="true">// 将属性存储在某一模块下</span>  <span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span>module_name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>module_name<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">let</span> val <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>module_name<span class="token punctuation">)</span><span class="token punctuation">;</span>      val<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>module_name<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>      <span class="token keyword">let</span> val <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getStorage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      val<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>      window<span class="token punctuation">.</span>sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>STORAGE_KEY<span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 获取某一个模块下面的属性</span>  <span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>module_name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>module_name<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">let</span> val <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>module_name<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> val<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getStorage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">getStorage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>STORAGE_KEY<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">'{}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、localStorage"><a href="#3、localStorage" class="headerlink" title="3、localStorage"></a>3、localStorage</h3><p>localStorage 类似 sessionStorage，但其区别在于：存储在 localStorage 的数据可以长期保留；而当页面会话结束（即当页面被关闭时），存储在 sessionStorage 的数据会被清除 。要访问同一个localStorage对象，页面必须来自同一个域（子域不可以）、在相同的端口上使用相同的协议。</p><p>考虑到 localStorage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串</p><p>有的网站还会用它存储一些不经常更新的 CSS、JS 等静态资源。</p><h3 id="4、Web-Storage与cookie-之间的区别"><a href="#4、Web-Storage与cookie-之间的区别" class="headerlink" title="4、Web Storage与cookie 之间的区别"></a>4、Web Storage与cookie 之间的区别</h3><p>我们先来说说两者的共同点，然后再细说下哪些地方有区别：</p><ul><li>共同点：都是保存在浏览器端，且都遵循同源策略。</li><li>不同点：在于生命周期与作用域的不同</li></ul><p>作用域：localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。不过sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下</p><p>生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p><p>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！</p><h2 id="三、IndexedDB"><a href="#三、IndexedDB" class="headerlink" title="三、IndexedDB"></a>三、IndexedDB</h2><p>Indexed Database API简称IndexedDB，是浏览器中存储结构化数据的一个方案。IndexedDB背后的思想是创造一套API，方便JavaScript对象的存储和获取，同时也支持查询和搜索。</p><p>IndexedDB是类似于MySQL或Web SQL Database的数据库。与传统数据库最大的区别在于，<strong>IndexedDB使用对象存储而不是表格保存数据。</strong>IndexedDB数据库就是在一个公共命名空间下的一组对象存储，类似于NoSQL风格的实现。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。</p><h3 id="1-IndexedDB的特点"><a href="#1-IndexedDB的特点" class="headerlink" title="1.IndexedDB的特点"></a>1.IndexedDB的特点</h3><ul><li><p>键值对储存。<br>IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p></li><li><p>异步</p></li></ul><p><strong>IndexedDB的设计几乎完全是异步的。</strong>为此，大多数操作以请求的形式执行，这些请求会异步执行，产生成功的结果或错误。绝大多数IndexedDB操作要求添加onerror和onsuccess事件处理程序来确定输出。IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 localStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p><ul><li><p>支持事务。<br>IndexedDB <strong>支持事务</strong>（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p></li><li><p>同源限制<br>IndexedDB <strong>受到同源限制，每一个数据库对应创建它的域名。</strong>网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p></li><li><p>储存空间大<br>IndexedDB 的储存空间比 localStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p></li><li><p>支持二进制储存。<br>IndexedDB 不仅可以储存字符串，<strong>还可以储存二进制数据</strong>（ArrayBuffer 对象和 Blob 对象）。</p></li></ul><h3 id="2-IndexedDB-使用流程"><a href="#2-IndexedDB-使用流程" class="headerlink" title="2.IndexedDB 使用流程"></a>2.IndexedDB 使用流程</h3><p>在IndexedDB大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求——响应的模式。</p><p>接下来，通过一个基本的 IndexedDB 使用流程，旨在对 IndexedDB 形成一个感性的认知：</p><ul><li>打开/创建一个 IndexedDB 数据库（当该数据库不存在时，open 方法会直接创建一个名为 admin 新数据库）</li></ul><pre class="line-numbers language-js"><code class="language-js">  <span class="token comment" spellcheck="true">// 后面的回调中，我们可以通过event.target.result拿到数据库实例</span>  <span class="token keyword">let</span> db  <span class="token comment" spellcheck="true">// 参数1位数据库名，参数2为版本号</span>  <span class="token keyword">const</span> request <span class="token operator">=</span> window<span class="token punctuation">.</span>indexedDB<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 使用IndexedDB失败时的监听函数</span>  request<span class="token punctuation">.</span>onerror <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'无法使用IndexedDB'</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 成功</span>  request<span class="token punctuation">.</span>onsuccess  <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 此处就可以获取到db实例</span>    db <span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>result    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"你打开了IndexedDB"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>创建一个 object store（object store 对标到数据库中的“表”单位）</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// onupgradeneeded事件会在初始化数据库/版本发生更新时被调用，我们在它的监听函数中创建object store</span>request<span class="token punctuation">.</span>onupgradeneeded <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">let</span> objectStore<span class="token comment" spellcheck="true">// 如果同名表未被创建过，则新建test表</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>db<span class="token punctuation">.</span>objectStoreNames<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  objectStore <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">createObjectStore</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> keyPath<span class="token punctuation">:</span> <span class="token string">'id'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>构建一个事务来执行一些数据库操作，像增加或提取数据等</p></li></ul><pre class="line-numbers language-js"><code class="language-js">  <span class="token comment" spellcheck="true">// 创建事务，指定表格名称和读写权限</span>  <span class="token keyword">const</span> transaction <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">transaction</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"test"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"readwrite"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 拿到Object Store对象</span>  <span class="token keyword">const</span> objectStore <span class="token operator">=</span> transaction<span class="token punctuation">.</span><span class="token function">objectStore</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 向表格写入数据</span>  objectStore<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">{</span>id<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'juejin'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过监听正确类型的事件以等待操作完成。</li></ul><pre class="line-numbers language-js"><code class="language-js">  <span class="token comment" spellcheck="true">// 操作成功时的监听函数</span>  transaction<span class="token punctuation">.</span>oncomplete <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"操作成功"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 操作失败时的监听函数</span>  transaction<span class="token punctuation">.</span>onerror <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"这里有一个Error"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Web-Storage、cookie-和-IndexedDB之间的区别"><a href="#3-Web-Storage、cookie-和-IndexedDB之间的区别" class="headerlink" title="3.Web Storage、cookie 和 IndexedDB之间的区别"></a>3.Web Storage、cookie 和 IndexedDB之间的区别</h3><table><thead><tr><th>特性</th><th>cookie</th><th>localStorage</th><th>sessionStorage</th><th>indexDB</th></tr></thead><tbody><tr><td>数据生命周期</td><td>一般由服务器生成，可以设置过期时间</td><td>除非被清理，否则一直存在</td><td>页面关闭就清理</td><td>除非被清理，否则一直存在</td></tr><tr><td>数据存储大小</td><td>4K</td><td>5M</td><td>5M</td><td>无限</td></tr><tr><td>与服务端通信</td><td>每次都会携带在header中，对于请求性能影响</td><td>不参与</td><td>不参与</td><td>不参与</td></tr></tbody></table><p>有了这些存储手段，就可以在客户端通过使用JavaScript存储可观的数据。因为这些数据没有加密，所以要注意不能使用它们存储敏感信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正是浏览器存储、缓存技术的出现和发展，为我们的前端应用带来了无限的转机。近年来基于存储、缓存技术的第三方库层出不绝，此外还衍生出了 PWA 这样优秀的 Web 应用模型。总结下本文几个核心观点：</p><ul><li>Cookie 的本职工作并非本地存储，而是“维持状态”。</li><li>Web Storage定义了两个对象用于存储数据：sessionStorage和localStorage。前者用于严格保- 存浏览器一次会话期间的数据，因为数据会在浏览器关闭时被删除。后者用于会话之外持久保存数据。</li><li>IndexedDB是类似于SQL数据库的结构化数据存储机制。不同的是，IndexedDB存储的是对象，而不是数据表。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的回流与重绘 (Reflow &amp; Repaint)</title>
      <link href="/posts/3d62f822.html"/>
      <url>/posts/3d62f822.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在讨论回流与重绘之前，我们要知道：</p><p>浏览器使用流式布局模型 (Flow Based Layout)。<br>浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。<br>有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。<br>由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。</p><p>一句话：回流必将引起重绘，重绘不一定会引起回流。</p><h2 id="回流-Reflow"><a href="#回流-Reflow" class="headerlink" title="回流 (Reflow)"></a>回流 (Reflow)</h2><p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。<br>会导致回流的操作：</p><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除可见的DOM元素</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法</li></ul><p>一些常用且会导致回流的属性和方法：</p><blockquote><p>clientWidth、clientHeight、clientTop、clientLeft<br>offsetWidth、offsetHeight、offsetTop、offsetLeft<br>scrollWidth、scrollHeight、scrollTop、scrollLeft<br>scrollIntoView()、scrollIntoViewIfNeeded()<br>getComputedStyle()<br>getBoundingClientRect()<br>scrollTo()</p></blockquote><h2 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘 (Repaint)"></a>重绘 (Repaint)</h2><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><h2 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h2><p><strong>回流比重绘的代价要更高。</strong></p><p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。<br>现代浏览器会对频繁的回流或重绘操作进行优化：<br>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。<br>当你访问以下属性或方法时，浏览器会立刻清空队列：</p><blockquote><p>clientWidth、clientHeight、clientTop、clientLeft<br>offsetWidth、offsetHeight、offsetTop、offsetLeft<br>scrollWidth、scrollHeight、scrollTop、scrollLeft<br>width、height<br>getComputedStyle()<br>getBoundingClientRect()</p></blockquote><p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li>避免使用table布局。</li><li>尽可能在DOM树的最末端改变class。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到position属性为absolute或fixed的元素上。</li><li>避免使用CSS表达式（例如：calc()）。</li></ul><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul><li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li><li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li><li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器渲染原理</title>
      <link href="/posts/a074b2a4.html"/>
      <url>/posts/a074b2a4.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，另一个是JS引擎。渲染引擎在不同的浏览器中也不是都相同的。目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。这里面大家最耳熟能详的可能就是 Webkit 内核了，Webkit 内核是当下浏览器世界真正的霸主。<br>本文我们就以 Webkit 为例，对现代浏览器的渲染过程进行一个深度的剖析。</p><h2 id="二、页面加载过程"><a href="#二、页面加载过程" class="headerlink" title="二、页面加载过程"></a>二、页面加载过程</h2><p>在介绍浏览器渲染过程之前，我们简明扼要介绍下页面的加载过程，有助于更好理解后续渲染过程。</p><p>要点如下：</p><ul><li>浏览器根据 DNS 服务器得到域名的 IP 地址</li><li>向这个 IP 的机器发送 HTTP 请求</li><li>服务器收到、处理并返回 HTTP 请求</li><li>浏览器得到返回内容</li></ul><p>服务端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求，返回的内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/aa60a0b569fd254f9097e8a6fe38745d1ae61f5b14b8ad1e86259b2940b607f1/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f342f312f313639643437636265303365303130333f773d36383426683d31363826663d706e6726733d3831343836"></p><p>其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。</p><h2 id="三、浏览器渲染过程"><a href="#三、浏览器渲染过程" class="headerlink" title="三、浏览器渲染过程"></a>三、浏览器渲染过程</h2><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/a679584d3c433486d8d8500da35a26547f96d962862f1e45f1df1dd80361b3cc/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32372f313637663035373730346239346630383f773d37303526683d32323726663d706e6726733d313630323734"></p><p>浏览器渲染过程大体分为如下三部分：</p><h3 id="1）浏览器会解析三个东西："><a href="#1）浏览器会解析三个东西：" class="headerlink" title="1）浏览器会解析三个东西："></a>1）浏览器会解析三个东西：</h3><ul><li>一是HTML/SVG/XHTML，HTML字符串描述了一个页面的结构，浏览器会把HTML结构字符串解析转换DOM树形结构。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/ebce920eb1889607f6613624f5267fdcba290e822db43880a2c23e9aa70d640c/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643437303433376136633135613f773d35383726683d31313026663d67696626733d3938323337"></p><ul><li>二是CSS，解析CSS会产生CSS规则树，它和DOM结构比较像。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/fb2dc137c7e2894ba3379bab924b566c6ac602f94a831d6858b67fec7435e182/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643437386130663462643136633f773d36363426683d31343626663d706e6726733d3332383833"></p><ul><li>三是Javascript脚本，等到Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/de44c6e85c2379280d08aa35beb63ccc16a709a942edbb3c3a1935988e6fbe3a/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643437383065306133666134343f773d35373926683d31393726663d67696626733d313434303837"></p><h3 id="2）解析完成后，浏览器引擎会通过DOM-Tree-和-CSS-Rule-Tree-来构造-Rendering-Tree。"><a href="#2）解析完成后，浏览器引擎会通过DOM-Tree-和-CSS-Rule-Tree-来构造-Rendering-Tree。" class="headerlink" title="2）解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。"></a>2）解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。</h3><ul><li>Rendering Tree 渲染树并不等同于DOM树，渲染树只会包括需要显示的节点和这些节点的样式信息。</li><li>CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element（也就是每个Frame）。</li><li>然后，计算每个Frame 的位置，这又叫layout和reflow过程。</li></ul><h3 id="3）最后通过调用操作系统Native-GUI的API绘制。"><a href="#3）最后通过调用操作系统Native-GUI的API绘制。" class="headerlink" title="3）最后通过调用操作系统Native GUI的API绘制。"></a>3）最后通过调用操作系统Native GUI的API绘制。</h3><p>接下来我们针对这其中所经历的重要步骤详细阐述</p><h2 id="四、构建DOM"><a href="#四、构建DOM" class="headerlink" title="四、构建DOM"></a>四、构建DOM</h2><p>浏览器会遵守一套步骤将HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/01b494550bf1b8555b68cf1a5fc2bee8ad374baa06867d02ba0b5d9e233d7ee1/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32382f313637663532363266356430616164643f773d36323326683d383826663d706e6726733d3330383134" alt="构建DOM的具体步骤"></p><ul><li><p>浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成字符串。<br>在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。</p></li><li><p>将字符串转换成Token，例如：&lt;html&gt;、&lt;body&gt; 等。<strong>Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息。</strong></p></li></ul><p>这时候你一定会有疑问，节点与节点之间的关系如何维护？</p><p>事实上，这就是Token要标识“起始标签”和“结束标签”等标识的作用。例如“title”Token的起始标签和结束标签之间的节点肯定是属于“head”的子节点。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/610102d6bf6b3a7a5de4106136a0e5838c9dd07be7fc6cbd666dc663b3d24fa8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32382f313637663534613463653134396130353f773d36373126683d31363826663d706e6726733d3533313535"></p><p>上图给出了节点之间的关系，例如：“Hello”Token位于“title”开始标签与“title”结束标签之间，表明“Hello”Token是“title”Token的子节点。同理“title”Token是“head”Token的子节点。</p><ul><li>生成节点对象并构建DOM</li></ul><p>事实上，构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。<strong>注意：带有结束标签标识的Token不会创建节点对象。</strong></p><p>接下来我们举个例子，假设有段HTML文本：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Web page parsing<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Web page parsing<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>This is an example Web page.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这段HTML会解析成这样：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/a43322eaf266d47f11f824cdc521acb544b6dce2424b603c1c750dacffd5e936/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32382f313637663532326534643463356532623f773d34363826683d33303826663d706e6726733d313230393137"></p><h2 id="五、构建CSSOM"><a href="#五、构建CSSOM" class="headerlink" title="五、构建CSSOM"></a>五、构建CSSOM</h2><p>DOM会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建CSSOM。</p><p>构建CSSOM的过程与构建DOM的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/e189f627df73913b53930e0e4cf844704459dab51c363ec6a4de2dfbd9cbdadb/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32382f313637663535616162616364346261633f773d36373926683d383526663d706e6726733d3332393736"></p><p>在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。</p><p><strong>注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。</strong></p><h2 id="六、构建渲染树"><a href="#六、构建渲染树" class="headerlink" title="六、构建渲染树"></a>六、构建渲染树</h2><p>当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/d947d9dd52428474b1609656ce05dcffb55ec1ef9854fc4067c4280d43c2a747/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32382f313637663536353235323166656132663f773d36383926683d33323726663d706e6726733d313235303739"></p><p>在这一过程中，不是简单的将两者合并就行了。<strong>渲染树只会包括需要显示的节点和这些节点的样式信息，</strong>如果某个节点是 display: none 的，那么就不会在渲染树中显示。</p><p>我们或许有个疑惑：<strong>浏览器如果渲染过程中遇到JS文件怎么处理？</strong></p><p>渲染过程中，如果遇到 &lt;script&gt; 就停止渲染，执行 JS 代码。因为浏览器有GUI渲染线程与JS引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。</p><p>也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性（下文会介绍这两者的区别）。</p><p><strong>JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。</strong></p><p>原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。</p><p>这是什么情况？</p><p>这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，<strong>在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/c2fa23ed114a491379d43e1a6ca34a9a29d8e0d144bbbb287b1d299927af5ae7/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f342f322f313639646562646430396565636361613f773d36383926683d32303926663d706e6726733d3531333132"></p><h2 id="七、布局与绘制"><a href="#七、布局与绘制" class="headerlink" title="七、布局与绘制"></a>七、布局与绘制</h2><p>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</p><p>布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。</p><p>布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。</p><blockquote><p>以上我们详细介绍了浏览器工作流程中的重要步骤，接下来我们讨论几个相关的问题：</p></blockquote><h2 id="八、几点补充说明"><a href="#八、几点补充说明" class="headerlink" title="八、几点补充说明"></a>八、几点补充说明</h2><h3 id="1-async和defer的作用是什么？有什么区别"><a href="#1-async和defer的作用是什么？有什么区别" class="headerlink" title="1.async和defer的作用是什么？有什么区别?"></a>1.async和defer的作用是什么？有什么区别?</h3><p>接下来我们对比下 defer 和 async 属性的区别：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/692889ad40496efb504f771f26875a2e220abc783c7f27c0c24e8f29dea8a2ce/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f362f31362f313634303635366537303736356163373f773d36383926683d31313226663d6a70656726733d3136383935" alt="async和defer"></p><p>其中蓝色线代表JavaScript加载；红色线代表JavaScript执行；绿色线代表 HTML 解析。</p><h4 id="1）情况1-lt-script-src-”script-js”-gt-lt-script-gt"><a href="#1）情况1-lt-script-src-”script-js”-gt-lt-script-gt" class="headerlink" title="1）情况1 <script src=”script.js”></script>"></a>1）情况1 &lt;script src=”script.js”&gt;&lt;/script&gt;</h4><p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><h4 id="2）情况2-lt-script-async-src-”script-js”-gt-lt-script-gt-异步下载"><a href="#2）情况2-lt-script-async-src-”script-js”-gt-lt-script-gt-异步下载" class="headerlink" title="2）情况2 <script async src=”script.js”></script> (异步下载)"></a>2）情况2 &lt;script async src=”script.js”&gt;&lt;/script&gt; (异步下载)</h4><p>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</p><h4 id="3）情况3-lt-script-defer-src-”script-js”-gt-lt-script-gt-延迟执行"><a href="#3）情况3-lt-script-defer-src-”script-js”-gt-lt-script-gt-延迟执行" class="headerlink" title="3）情况3 <script defer src=”script.js”></script>(延迟执行)"></a>3）情况3 &lt;script defer src=”script.js”&gt;&lt;/script&gt;(延迟执行)</h4><p>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</p><p>defer 与相比普通 script，有两点区别：<strong>载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。</strong><br><strong>在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。</strong></p><h3 id="2-为什么操作-DOM-慢"><a href="#2-为什么操作-DOM-慢" class="headerlink" title="2.为什么操作 DOM 慢"></a>2.为什么操作 DOM 慢</h3><p>把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》</p><p>JS 是很快的，在 JS 中修改 DOM 对象也是很快的。在JS的世界里，一切是简单的、迅速的。但 DOM 操作并非 JS 一个人的独舞，而是两个模块之间的协作。</p><p>因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了“跨界交流”。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”（如下图）。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/bf3080cb4c1dc3f2856b6cbfcbb2e738358456e53358c0cea22a260b0bc6ca2b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f342f332f313639653364633063346134333866643f773d35373826683d31383826663d706e6726733d3431323633"></p><p>过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少 DOM 操作”的建议，并非空穴来风。</p><h3 id="3-你真的了解回流和重绘吗"><a href="#3-你真的了解回流和重绘吗" class="headerlink" title="3.你真的了解回流和重绘吗"></a>3.你真的了解回流和重绘吗</h3><p>渲染的流程基本上是这样（如下图黄色的四个步骤）：</p><ul><li>计算CSS样式 </li><li>构建Render Tree </li><li>Layout – 定位坐标和大小 </li><li>正式开画</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/41efc5b1210ddb69665db7fd882484a0856d30be4d16082acf821af5da4cc5e0/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32382f313637663036386534646536633763653f773d37313326683d31393526663d706e6726733d313433383132"></p><p>注意：上图流程中有很多连接线，这表示了Javascript动态修改了DOM属性或是CSS属性会导致重新Layout，但有些改变不会重新Layout，就是上图中那些指到天上的箭头，比如修改后的CSS rule没有被匹配到元素。</p><p>这里重要要说两个概念，一个是Reflow，另一个是Repaint</p><ul><li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。</li><li>回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）</li></ul><p>我们知道，当网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染。重新渲染会重复回流+重绘或者只有重绘。</p><p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong>重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><h4 id="1）常见引起回流属性和方法"><a href="#1）常见引起回流属性和方法" class="headerlink" title="1）常见引起回流属性和方法"></a>1）常见引起回流属性和方法</h4><p>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流，</p><p>添加或者删除可见的DOM元素；<br>元素尺寸改变——边距、填充、边框、宽度和高度<br>内容变化，比如用户在input框中输入文字<br>浏览器窗口尺寸改变——resize事件发生时<br>计算 offsetWidth 和 offsetHeight 属性<br>设置 style 属性的值</p><h4 id="2）常见引起重绘属性和方法"><a href="#2）常见引起重绘属性和方法" class="headerlink" title="2）常见引起重绘属性和方法"></a>2）常见引起重绘属性和方法</h4><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/26146109ab8f4b81560ba629ef479ffe4efc84acce73242ee92f7bd394f96645/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f312f313638303964386536343832623831333f773d35353426683d32333526663d706e6726733d3132303735"></p><h4 id="3）如何减少回流、重绘"><a href="#3）如何减少回流、重绘" class="headerlink" title="3）如何减少回流、重绘"></a>3）如何减少回流、重绘</h4><ul><li>使用 transform 替代 top</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）<br>不要把节点的属性值放在一个循环里当成循环里的变量。<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.test'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>offsetTop<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</li><li>CSS 选择符从右往左匹配查找，避免节点层级过多</li><li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。</li></ul><h2 id="九、性能优化策略"><a href="#九、性能优化策略" class="headerlink" title="九、性能优化策略"></a>九、性能优化策略</h2><p>基于上面介绍的浏览器渲染原理，DOM 和 CSSOM 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。</p><ul><li>JS优化： &lt;script&gt; 标签加上 defer属性 和 async属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。<ul><li>defer属性： 用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。</li><li>async属性： HTML5新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。</li></ul></li><li>CSS优化： &lt;link&gt; 标签的 rel属性 中的属性值设置为 preload 能够让你在你的HTML页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能</li></ul><h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><p>综上所述，我们得出这样的结论：</p><ul><li>浏览器工作流程：构建DOM -&gt; 构建CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制。</li><li>CSSOM会阻塞渲染，只有当CSSOM构建完毕后才会进入下一个阶段构建渲染树。</li><li>通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个不带defer或async属性的script标签时，DOM构建将暂停，如果此时又恰巧浏览器尚未完成CSSOM的下载和构建，由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS，最后才重新DOM构建。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全</title>
      <link href="/posts/2812c128.html"/>
      <url>/posts/2812c128.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>浏览器安全可以分为三大块：</p><ul><li>Web 页面安全</li><li>浏览器网络安全</li><li>浏览器系统安全</li></ul><p>Web 世界是开放的，任何资源都可以接入其中，我们的网站可以加载并执行别人网站的脚本文件、图片、音频、视频等资源，甚至可以下载其他站点的可执行文件。</p><p>但是 Web 世界不能绝对自由，例如打开一个银行站点，不小心又打开一个恶意站点：</p><ul><li>修改银行站点的 DOM、CSSOM 等信息；</li><li>在银行站点内部插入 JavaScript 脚本；</li><li>劫持用户登录的用户名和密码；</li><li>读取银行站点的 Cookie、IndexDB 等数据；</li><li>甚至还可以将这些信息上传至自己的服务器，这样就可以在你不知情的情况下伪造一些转账请求等信息。</li></ul><p>所以，在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。</p><p>这就引出了页面中最基础、最核心的安全策略：同源策略（Same-origin policy）。</p><h2 id="二、同源策略"><a href="#二、同源策略" class="headerlink" title="二、同源策略"></a>二、同源策略</h2><h3 id="2-1-什么是同源策略"><a href="#2-1-什么是同源策略" class="headerlink" title="2.1 什么是同源策略"></a>2.1 什么是同源策略</h3><p>所谓 <strong>源</strong>，可以指 URL。</p><p>而所谓的同源，是指 <strong>协议、域名、端口</strong> 一致的情况下，才属于同源。</p><p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</p><h3 id="2-2-为什么需要同源策略"><a href="#2-2-为什么需要同源策略" class="headerlink" title="2.2 为什么需要同源策略"></a>2.2 为什么需要同源策略</h3><p>同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p><ul><li><strong>第一个，DOM 层面</strong><br>同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</li></ul><p>当你在 A 页面，通过 &lt;a href=”xxx” target=”_blank”&gt; 的形式打开 B 页面，经过下面 2 行代码可以将 A 页面的内容给隐藏掉：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> pdom <span class="token operator">=</span> opener<span class="token punctuation">.</span>document<span class="token punctuation">;</span>pdom<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">"none"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这就是同源情况下 DOM 的一个操作。</p><p>而不同源的是无法操作的。</p><ul><li><strong>第二个，数据层面</strong><br>同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。</li></ul><p>由于同源策略，我们依然无法通过 B 页面的 opener 来访问 A 页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。</p><ul><li><strong>第三个，网络层面</strong><br>同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</li></ul><h2 id="三、XSS"><a href="#三、XSS" class="headerlink" title="三、XSS"></a>三、XSS</h2><h3 id="3-1-概览"><a href="#3-1-概览" class="headerlink" title="3.1 概览"></a>3.1 概览</h3><p>本章目标：看到下面概览可以大略描述说出 XSS 攻击、XSS 攻击类型以及 XSS 防御措施。</p><ul><li>XSS 攻击类型</li></ul><ol><li>存储型</li><li>反射型</li><li>文档型</li></ol><ul><li>XSS 防范措施</li></ul><ol><li>输入检查</li><li>利用 CSP</li><li>利用 HttpOnly</li></ol><h3 id="3-2-介绍"><a href="#3-2-介绍" class="headerlink" title="3.2 介绍"></a>3.2 介绍</h3><p>XSS（Cross Site Script）跨站脚本攻击。指的是攻击者向网页注入恶意的客户端代码，通过恶意的脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p><p>例如：</p><ul><li>可以窃取 Cookie 信息。恶意 JavaScript 可以通过 document.cookie 获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器。恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li><li>可以监听用户行为。恶意 JavaScript 可以使用 addEventListener 接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li><li>可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li><li>可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。</li></ul><p>注入恶意脚本分 3 种方式：</p><ul><li><strong>存储型</strong>：即攻击被存储在服务端，常见的是在评论区插入攻击脚本，如果脚本被储存到服务端，那么所有看见对应评论的用户都会受到攻击。例如 2015 年喜马拉雅的专辑名称允许用户编写 &lt;script&gt; 标签。</li><li><strong>反射型：</strong>攻击者将脚本混在 URL 里，服务端接收到 URL 将恶意代码当做参数取出并拼接在 HTML 里返回，浏览器解析此 HTML 后即执行恶意代码。例如 Q 群或者邮件中发送恶意链接，用户点击恶意链接，然后解析 URL 执行恶意代码。</li><li><strong>DOM 型：</strong>攻击者通过各种手段将恶意脚本注入用户的页面中。例如通过网络劫持（WiFi 路由器劫持、本地恶意软件劫持等）在页面传输过程中修改 HTML 页面内容。</li></ul><h3 id="3-3-防御"><a href="#3-3-防御" class="headerlink" title="3.3 防御"></a>3.3 防御</h3><p>防御 XSS 攻击：</p><ul><li><strong>输入检查：</strong>对输入内容中的 script 和 &lt;iframe&gt; 等标签进行转义或者过滤</li><li><strong>设置 httpOnly：</strong>设置此属性可防止 JavaScript 获取 Cookie，只能在 HTTP 请求过程中使用 Cookie</li><li><strong>开启 CSP 白名单：</strong>即开启白名单，可阻止白名单以外的资源加载和运行</li></ul><h2 id="四、CSRF"><a href="#四、CSRF" class="headerlink" title="四、CSRF"></a>四、CSRF</h2><h3 id="4-1-概览"><a href="#4-1-概览" class="headerlink" title="4.1 概览"></a>4.1 概览</h3><p>本章目标：看到下面概览可以大略描述说出 CSRF 攻击、CSRF 攻击方式以及 CSRF 防御措施。</p><ul><li>CSRF 攻击方式</li></ul><ol><li>利用用户的登录状态，并通过第三方的站点来做一些坏事</li><li>自动发 GET 请求</li><li>自动发 POST 请求</li><li>诱导点击发送 GET 请求</li></ol><ul><li>CSRF 防范措施</li></ul><ol><li>验证 Token</li><li>验证 Referer</li><li>验证 Samesite</li></ol><h3 id="4-2-介绍"><a href="#4-2-介绍" class="headerlink" title="4.2 介绍"></a>4.2 介绍</h3><p>CSRF 攻击（Cross-site request forgery）即跨站请求伪造。</p><p>是一种劫持受信任用户向服务器发送非预期请求的攻击方式，通常情况下，它是攻击者借助受害者的 Cookie 骗取服务器的信任，但是它并不能拿到 Cookie，也看不到 Cookie 的内容，它能做的就是给服务器发送请求，然后执行请求中所描述的命令，以此来改变服务器中的数据，也就是并不能窃取服务器中的数据。</p><p>CSRF 攻击就是黑客利用用户的登录状态，并通过第三方的站点来做一些坏事。</p><p>打开攻击者提供的页面后，攻击者有 3 种方式实施 CSRF 攻击：</p><h4 id="方法一：自动发起-Get-请求"><a href="#方法一：自动发起-Get-请求" class="headerlink" title="方法一：自动发起 Get 请求"></a>方法一：自动发起 Get 请求</h4><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>黑客的站点：CSRF 攻击演示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://jsliang.top/index.html?user<span class="token punctuation">=</span>hacker&amp;number<span class="token punctuation">=</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。</p><p>当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的 100 块就被转移到黑客的账户上去了。</p><h4 id="方法二：自动发起-POST-请求"><a href="#方法二：自动发起-POST-请求" class="headerlink" title="方法二：自动发起 POST 请求"></a>方法二：自动发起 POST 请求</h4><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>黑客的站点：CSRF 攻击演示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>hacker-form<span class="token punctuation">'</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://jsliang.top<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span>POST</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hacker<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'hacker-form'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口。</p><p>当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。</p><p>因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。</p><h4 id="方法三：引诱用户点击链接"><a href="#方法三：引诱用户点击链接" class="headerlink" title="方法三：引诱用户点击链接"></a>方法三：引诱用户点击链接</h4><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span>150</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span>http://images.xuejuzi.cn/1612/1_161230185104_1.jpg</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://jsliang.top?user<span class="token punctuation">=</span>hacker&amp;number<span class="token punctuation">=</span>100<span class="token punctuation">"</span></span> <span class="token attr-name">taget</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    点击下载美女照片  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传说中的色诱，或者 “点击即送 100w 元” 之类的。</p><h3 id="4-3-防御"><a href="#4-3-防御" class="headerlink" title="4.3 防御"></a>4.3 防御</h3><p>防御 CSRF 攻击：</p><ul><li>验证 Token：浏览器请求服务器时，服务器返回一个 token，之后每个请求都需要同时带上 token 和 Cookie 才会被认为是合法请求</li><li>验证 Referer：通过验证请求头的 Referer 来验证来源站点，但请求头很容易伪造</li><li>设置 SameSite：设置 Cookie 的 SameSite，可以让 Cookie 不随跨站请求发出，但浏览器兼容不一</li></ul><h2 id="五、SQL注入"><a href="#五、SQL注入" class="headerlink" title="五、SQL注入"></a>五、SQL注入</h2><p>已有代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/login<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Username: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Password: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>登陆<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后端的登录语句：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> querySQL <span class="token operator">=</span> <span class="token template-string"><span class="token string">`  SELECT *  FROM user  WHERE username='</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>username<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'  AND psw='</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>password<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'`</span></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 接下来就是执行 sql 语句...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>攻击者输入的信息是：</p><ul><li>用户名：jsliang’ OR 1 = 1 –</li><li>密码：随意，例如 123456</li></ul><p>预想输入和现在输入变成：</p><pre class="line-numbers language-js"><code class="language-js">SELECT <span class="token operator">*</span> FROM user WHERE username<span class="token operator">=</span><span class="token string">'jsliang'</span> AND psw<span class="token operator">=</span><span class="token string">'123456'</span>SELECT <span class="token operator">*</span> FROM user WHERE username<span class="token operator">=</span><span class="token string">'jsliang'</span> OR <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">--</span><span class="token string">' AND psw='</span>xxxx'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们先拆解这条 SQL 语句，避免有些小伙伴看不懂：</p><ul><li>SELECT：查找</li><li>*：所有信息</li><li>FROM：来源于某个表（From xxx）</li><li>user：用户表</li><li>username=’xxx’：用户名是 xxx</li><li>AND：和</li><li>OR：或</li><li>–：注释，跟我们 JS 的 // 一样</li></ul><p>所以上面代码的意思是：</p><ul><li>第一条：查找 user 表，其中 username 为 jsliang，并且密码是 123456</li><li>第二条：查找 user 表，其中 username 为 jsliang，或者 1 = 1</li></ul><p>这样，第二条的 SQL 查询条件就必定是真的啦，我们就可以登录这个账号了。</p><p>这就是 SQL 注入。</p><p>怎么预防？这里我们不理会，属于后端需要注意的范畴。</p><p>当然后端可能要求前端帮忙防范，比如用户名不能包含 -、_ 等~</p><h2 id="六、流量劫持"><a href="#六、流量劫持" class="headerlink" title="六、流量劫持"></a>六、流量劫持</h2><p>流量劫持基本分两种：DNS 劫持 和 HTTP 劫持，目的都是一样的，就是当用户访问 github.com 的时候，给你展示的并不是或者不完全是 github.com 提供的 “内容”。</p><h3 id="6-1-DNS-劫持"><a href="#6-1-DNS-劫持" class="headerlink" title="6.1 DNS 劫持"></a>6.1 DNS 劫持</h3><p>DNS 劫持，也叫做域名劫持。</p><p>当用户通过某一个域名访问一个站点的时候，被篡改的 DNS 服务器返回的是一个恶意的钓鱼站点的 IP，用户就被劫持到了恶意钓鱼站点，然后继而会被钓鱼输入各种账号密码信息，泄漏隐私。</p><p>这类劫持：</p><p>要不就是网络运营商搞的鬼，一般小的网络运营商与黑产勾结会劫持 DNS<br>要不就是电脑中毒，被恶意篡改了路由器的 DNS 配置，基本上做为开发者或站长却是很难察觉的，除非有用户反馈。</p><h3 id="6-2-HTTP-劫持"><a href="#6-2-HTTP-劫持" class="headerlink" title="6.2 HTTP 劫持"></a>6.2 HTTP 劫持</h3><p>HTTP 劫持主要是当用户访问某个站点的时候会经过运营商网络，而不法运营商和黑产勾结能够截获 HTTP 请求返回内容，并且能够篡改内容，然后再返回给用户，从而实现劫持页面。</p><p>轻则插入小广告，重则直接篡改成钓鱼网站页面骗用户隐私，就好比 jsliang 访问某 XXDN 网站，会出现 Google 广告，实际上问了其他人的是不会有这个的。</p><p>能够实施流量劫持的根本原因，是 HTTP 协议没有办法对通信对方的身份进行校验以及对数据完整性进行校验。如果能解决这个问题，则流量劫持将无法轻易发生。</p><p>所以防止 HTTP 劫持的方法只有将内容加密，让劫持者无法破解篡改，这样就可以防止 HTTP 劫持了。</p><p>HTTPS 是基于 SSL 协议的安全加密网络应用层协议，相当于 HTTP + SSL，可以很好地防止 HTTP 劫持。</p><h2 id="七、浏览器网络安全"><a href="#七、浏览器网络安全" class="headerlink" title="七、浏览器网络安全"></a>七、浏览器网络安全</h2><p>HTTP 在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，在通信过程中的一切内容都在中间人的掌握中。</p><p>使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为中间人攻击。</p><p>具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。</p><p>比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。</p><p>或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。</p><h2 id="八、浏览器系统安全"><a href="#八、浏览器系统安全" class="headerlink" title="八、浏览器系统安全"></a>八、浏览器系统安全</h2><p>浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序。</p><p>其中最常见的攻击方式是利用缓冲区溢出，不过需要注意这种类型的攻击和 XSS 注入的脚本是不一样的。</p><ul><li>XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。</li><li>通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。</li></ul><p>渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限。</p><p>基于此，在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。</p><p>将渲染进程和操作系统隔离的这道墙就是安全沙箱。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket 详解</title>
      <link href="/posts/53fd80d8.html"/>
      <url>/posts/53fd80d8.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>WebSocket 是 HTML5 新增的一种全双工通信协议，客户端和服务器基于 TCP 握手连接成功后，两者之间就可以建立持久性的连接，实现双向数据传输。</p><h2 id="二、WebSocket-和-HTTP"><a href="#二、WebSocket-和-HTTP" class="headerlink" title="二、WebSocket 和 HTTP"></a>二、WebSocket 和 HTTP</h2><p>我们知道 HTTP 协议是一种单向的网络协议，在建立连接后，它允许客户端向服务器发送请求资源后，服务器才会返回相应的数据，而服务器不能主动推送数据给客户端。</p><p>当时为什么这样设计呢？假设一些不良广告商主动将一些信息强行推送给客户端，这不得不说是一个灾难。</p><p>所以现在我们要做股票的实时行情，或者获取火车票的剩余票数等，就需要客户端和服务器之间反复地进行 HTTP 通讯，客户端不断地发送 GET 请求，去获取当前的实时数据。</p><p>下面介绍几种常见的方式。</p><h3 id="2-1-（短）轮询（Polling）"><a href="#2-1-（短）轮询（Polling）" class="headerlink" title="2.1 （短）轮询（Polling）"></a>2.1 （短）轮询（Polling）</h3><p>短轮询模式下，客户端每隔一段时间向服务器发送 HTTP 请求。</p><p>服务器收到请求后，将最新的数据发回给客户端。</p><p>这种情况下的弊端是非常明显的：某个时间段服务器没有更新内容，但是客户端每隔一段时间发送请求来询问，而这段时间内的请求是无效的。</p><p>这就导致了网络带宽的浪费。</p><h3 id="2-2-长轮询"><a href="#2-2-长轮询" class="headerlink" title="2.2 长轮询"></a>2.2 长轮询</h3><p>长轮询模式下，客户端向服务器发出请求，服务器并不一定会立即回应客户端，而是查看数据是否有更新。</p><p>如果数据更新了的话，那就立即发送数据给客户端；如果没有更新，那就保持这个请求，等待有新的数据到来，才将数据返回给客户端。</p><p>如果服务器长时间没有更新，那么一段时间后，请求变会超时，客户端收到消息后，会立即发送一个新的请求给服务器。</p><p>当然这种方式也有弊端：当服务器向客户端发送数据后，必须等待下一次请求才能将新的数据发出，这样客户端接收新数据就有一个最短时间间隔。</p><p>如果服务器更新频率较快，那么就会出现问题。</p><h3 id="2-3-WebSocket"><a href="#2-3-WebSocket" class="headerlink" title="2.3 WebSocket"></a>2.3 WebSocket</h3><p>基于前面的情况，为了彻底解决服务器主动向客户端发送数据的问题。</p><p>W3C 在 HTML5 中提供了一种让客户端与服务器之间进行全双工通讯的网络技术 WebSocket。</p><p>WebSocket 基于 TCP 协议，是一种全新的、独立的协议，与 HTTP 协议兼容却不会融入 HTTP 协议，仅仅作为 HTML5 的一部分。</p><h3 id="2-4-两者比对"><a href="#2-4-两者比对" class="headerlink" title="2.4 两者比对"></a>2.4 两者比对</h3><p>基于上面，小伙伴们大概了解了 WebSocket 的缘由了，这里再总结对比一下 HTTP 和 WebSocket。</p><ul><li>相同点</li></ul><ol><li>都需要建立 TCP 连接</li><li>都属于七层协议中的应用层协议 </li></ol><ul><li>不同点</li></ul><ol><li>HTTP 是单向数据流，客户端向服务器发送请求，服务器响应并返回数据；WebSocket 连接后可以实现客户端和服务器双向数据传递，除非某一端断开连接。</li><li>HTTP 的 url 使用 http// 或者 https// 开头，而 WebSocket 的 url 使用 ws// 开头</li></ol><h2 id="三、Socket-io"><a href="#三、Socket-io" class="headerlink" title="三、Socket.io"></a>三、Socket.io</h2><p>我们先来看 WebSocket 的一个使用方式：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">"ws//:xxx.xx"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>protocol<span class="token punctuation">]</span><span class="token punctuation">)</span>ws<span class="token punctuation">.</span>onopen <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  ws<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'send'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>ws<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ev<span class="token punctuation">.</span>data<span class="token punctuation">)</span>  ws<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>ws<span class="token punctuation">.</span>onclose <span class="token operator">=</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>ws<span class="token punctuation">.</span>onerror <span class="token operator">=</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>WebSocket 实例化后，前端可以通过上面介绍的方法进行对应的操作，看起来还是蛮简单的。</p><p>但是，如果想完全搭建一个 WebSocket 服务端比较麻烦，又浪费时间。</p><p>所以：Socket.io 基于 WebSocket，加上轮询机制以及其他的实时通讯方面的内容，实现的一个库，它在服务端实现了实时机制的响应代码。</p><p>也就是说，WebSocket 仅仅是 Socket.io 实现通讯的一个子集。</p><p>因此，WebSocket 客户端连接不上 Socket.io 服务端，Socket.io 客户端也连不上 WebSocket 服务端。</p><p>下面我们讲解下如何实现一个简单的聊天。</p><h3 id="3-1-服务端代码"><a href="#3-1-服务端代码" class="headerlink" title="3.1 服务端代码"></a>3.1 服务端代码</h3><p>package.json</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>  <span class="token string">"devDependencies"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"express"</span><span class="token punctuation">:</span> <span class="token string">"^4.15.2"</span><span class="token punctuation">,</span>    <span class="token string">"socket.io"</span><span class="token punctuation">:</span> <span class="token string">"^2.3.0"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>index.js</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> server <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> io <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'socket.io'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sendFile</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'index.html'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 开启 socket.io</span>io<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'connection'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>client<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 如果有新客户端进来，显示 ID</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`客户端 ID：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>client<span class="token punctuation">.</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 监听客户端的输入信息</span>  client<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'channel'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`客户端 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>client<span class="token punctuation">.</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 发送信息 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    io<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'broadcast'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 判断客户端是否关闭</span>  client<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'disconnect'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`客户端关闭：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>client<span class="token punctuation">.</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务监听 3000 端口'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，我们直接通过 npm i 安装依赖包后，直接通过 node index.js 可以开启服务。</p><p>当然，如果小伙伴们想手动装包，执行下面命令即可：</p><pre class="line-numbers language-js"><code class="language-js">npm i express socket<span class="token punctuation">.</span>io express <span class="token operator">-</span>D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-客户端代码"><a href="#3-2-客户端代码" class="headerlink" title="3.2 客户端代码"></a>3.2 客户端代码</h3><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width,initial-scale<span class="token punctuation">=</span>1.0,maximum-scale<span class="token punctuation">=</span>1.0,user-scalable<span class="token punctuation">=</span>no<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Socket.io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/socket.io/2.2.0/socket.io.slim.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>input<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>send<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content-wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> inputValue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 连接 socket.io</span>      <span class="token keyword">let</span> socket <span class="token operator">=</span> <span class="token function">io</span><span class="token punctuation">(</span><span class="token string">'http://localhost:3000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 将创建的信息以添加 p 标签的形式展示成列表</span>      socket<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'broadcast'</span><span class="token punctuation">,</span> data <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> content <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        content<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> data<span class="token punctuation">;</span>        document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#content-wrap'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 设置输入框的内容</span>      <span class="token keyword">let</span> inputChangeHandle <span class="token operator">=</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        inputValue <span class="token operator">=</span> ev<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 获取输入框并监听输入</span>      <span class="token keyword">let</span> inputDom <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#input"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      inputDom<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> inputChangeHandle<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 当用户点击发送信息的时候，进行数据交互</span>      <span class="token keyword">let</span> sendHandle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        socket<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'channel'</span><span class="token punctuation">,</span> inputValue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">let</span> btnDom <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      btnDom<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> sendHandle<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 打页面卸载的时候，通知服务器关闭</span>      window<span class="token punctuation">.</span>onunload <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        btnDom<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> sendHandle<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        inputDom<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> inputChangeHandle<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><p>Socket.io 不仅支持 WebSocket，还支持许多种轮询机制以及其他实时通信方式，并封装了通用的接口。</p><p>这些方式包含 Adobe Flash Socket、Ajax 长轮询、Ajax multipart streaming、持久 Iframe、JSONP 轮询等。</p><p>换句话说，当 Socket.io 检测到当前环境不支持 WebSocket 时，能够自动地选择最佳的方式来实现网络的实时通信。</p><p>这样，我们就对 WebSocket 有一定的了解，面试的时候就不慌了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS解析</title>
      <link href="/posts/9e319110.html"/>
      <url>/posts/9e319110.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、用户在浏览器的地址栏中敲入了网站的网址-，会发生哪些事情呢？"><a href="#一、用户在浏览器的地址栏中敲入了网站的网址-，会发生哪些事情呢？" class="headerlink" title="一、用户在浏览器的地址栏中敲入了网站的网址 ，会发生哪些事情呢？"></a>一、用户在浏览器的地址栏中敲入了网站的网址 ，会发生哪些事情呢？</h2><ul><li>用户在浏览器的地址栏中敲入了网站的网址</li><li>浏览器查找域名的IP地址</li><li>找到ip地址后，浏览器给web服务器发送一个HTTP请求</li><li>服务器“处理”请求</li><li>服务器发回一个HTML响应</li><li>浏览器开始显示HTML</li></ul><p>大概就是这样的过程，下面我们来仔细的分析下浏览器是如何查找到域名对应的ip地址的。</p><h2 id="二、DNS域名解析过程"><a href="#二、DNS域名解析过程" class="headerlink" title="二、DNS域名解析过程"></a>二、DNS域名解析过程</h2><p>　当用户在浏览器中输入ke.qq.com并按下回车键后：</p><ol><li><strong>查找浏览器缓存。</strong></li></ol><p>浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等。这个缓存时间太长和太短都不好，如果缓存时间太长，一旦域名被解析到的IP有变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致该域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。如果时间设置太短，会导致用户每次访问网站都要重新解析一次域名。</p><ol start="2"><li><strong>查找系统缓存。</strong></li></ol><p>如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。其实操作系统也会有一个域名解析的过程，在Windows中可以通过C:\Windows\System32\drivers\etc\hosts文件来设置，你可以将任何域名解析到任何能够访问的IP地址。如果你在这里指定了一个域名对应的IP地址，那么浏览器会首先使用这个IP地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正是因为有这种本地DNS解析的规程，所以黑客就有可能通过修改你的域名解析来把特定的域名解析到它指定的IP地址上，导致这些域名被劫持。</p><ol start="3"><li><strong>查找路由器缓存。</strong></li></ol><p>如果系统缓存中也找不到，那么查询请求就会发向路由器，它一般会有自己的DNS缓存。</p><ol start="4"><li><strong>查找ISP DNS 缓存。</strong></li></ol><p>运气实在不好，就只能查询ISP DNS 缓存服务器了。在我们的网络配置中都会有”DNS服务器地址”这一项，操作系统会把这个域名发送给这里设置的DNS，也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约80%的域名解析都到这里就已经完成了，所以ISP DNS主要承担了域名的解析工作。</p><ol start="5"><li><strong>递归搜索。</strong></li></ol><p>最无奈的情况发生了, 在前面都没有办法命中的DNS缓存的情况下：</p><ul><li>本地 DNS服务器即将该请求转发到互联网上的根域（即一个完整域名最后面的那个点，通常省略不写）。</li><li>根域将所要查询域名中的顶级域（假设要查询ke.qq.com，该域名的顶级域就是com）的服务器IP地址返回到本地DNS。</li><li>本地DNS根据返回的IP地址，再向顶级域（就是com域）发送请求。</li><li>com域服务器再将域名中的二级域（即ke.qq.com中的qq）的IP地址返回给本地DNS。</li><li>本地DNS再向二级域发送请求进行查询。</li><li>之后不断重复这样的过程，直到本地DNS服务器得到最终的查询结果，并返回到主机。这时候主机才能通过域名访问该网站。</li></ul><h2 id="三、DNS有关的安全问题"><a href="#三、DNS有关的安全问题" class="headerlink" title="三、DNS有关的安全问题"></a>三、DNS有关的安全问题</h2><ol><li><strong>DNS欺骗：</strong><br>DNS欺骗即域名信息欺骗是最常见的DNS安全问题。当一个DNS服务器掉入陷阱，使用了来自一个恶意DNS服务器的错误信息，那么该DNS服务器就被欺骗了。DNS欺骗会使那些易受攻击的DNS服务器产生许多安全问题，例如：将用户引导到错误的互联网站点，或者发送一个电子邮件到一个未经授权的邮件服务器。网络攻击者通常通过两种方法进行DNS欺骗。</li></ol><ul><li>缓存感染：黑客会熟练的使用DNS请求，将数据放入一个没有设防的DNS服务器的缓存当中。这些缓存信息会在客户进行DNS访问时返回给客户，从而将客户引导到入侵者所设置的运行木马的Web服务器或邮件服务器上，然后黑客从这些服务器上获取用户信息。</li><li>DNS信息劫持：入侵者通过监听客户端和DNS服务器的对话，通过猜测服务器响应给客户端的DNS查询ID。每个DNS报文包括一个相关联的16位ID号，DNS服务器根据这个ID号获取请求源位置。黑客在DNS服务器之前将虚假的响应交给用户，从而欺骗客户端去访问恶意的网站。</li><li>DNS重定向：攻击者能够将DNS名称查询重定向到恶意DNS服务器。这样攻击者可以获得DNS服务器的写权限</li></ul><ol start="2"><li><p><strong>拒绝服务攻击</strong> 　<br>黑客主要利用一些DNS软件的漏洞，如在BIND 9版本（版本9.2.0以前的 9系列）如果有人向运行BIND的设备发送特定的DNS数据包请求，BIND就会自动关闭。攻击者只能使BIND关闭，而无法在服务器上执行任意命令。如果得不到DNS服务，那么就会产生一场灾难：由于网址不能解析为IP地址，用户将无方访问互联网。这样，DNS产生的问题就好像是互联网本身所产生的问题，这将导致大量的混乱。</p></li><li><p><strong>分布式拒绝服务攻击</strong> 　　<br>DDOS 攻击通过使用攻击者控制的几十台或几百台计算机攻击一台主机，使得服务拒绝攻击更难以防范，更难以通过阻塞单一攻击源主机的数据流，来防范服务拒绝攻击。</p></li><li><p><strong>缓冲区漏洞溢出攻击</strong> 　　<br>黑客利用DNS服务器软件存在漏洞，比如对特定的输入没有进行严格检查，那幺有可能被攻击者利用，攻击者构造特殊的畸形数据包来对DNS服务器进行缓冲区溢出攻击。如果这一攻击成功，就会造成DNS服务停止，或者攻击者能够在DNS服务器上执行其设定的任意代码。</p></li></ol><h2 id="四、DNS有关的网络性能优化"><a href="#四、DNS有关的网络性能优化" class="headerlink" title="四、DNS有关的网络性能优化"></a>四、DNS有关的网络性能优化</h2><ol><li><strong>减少DNS查找，避免重定向</strong><br>　　<br>浏览器DNS缓存 、计算机DNS缓存、 服务器DNS缓存、使用Keep-Alive特性 来减少DNS查找。考虑影响DNS缓存的因素：</li></ol><ul><li>服务器可以设置TTL值表示DNS记录的存活时间。本机DNS缓存将根据这个TTL值判断DNS记录什么时候被抛弃，这个TTL值一般都不会设置很大，主要是考虑到快速故障转移的问题。</li><li>浏览器DNS缓存也有自己的过期时间，这个时间是独立于本机DNS缓存的，相对也比较短，例如chrome只有1分钟左右。</li><li>浏览器DNS记录的数量也有限制，如果短时间内访问了大量不同域名的网站，则较早的DNS记录将被抛弃，必须重新查找。不过即使浏览器丢弃了DNS记录，操作系统的DNS缓存也有很大机率保留着该记录，这样可以避免通过网络查询而带来的延迟。</li></ul><ol start="2"><li><strong>DNS的预解析</strong></li></ol><ul><li>可以通过用meta信息来告知浏览器, 我这页面要做DNS预解析</li></ul><pre class="line-numbers language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>x-dns-prefetch-control<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>on<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>可以使用link标签来强制对DNS做预解析:</li></ul><pre class="line-numbers language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dns-prefetch<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://ke.qq.com/<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。较少的域名来减少DNS查找（2-4个主机）</li></ul><h2 id="五、DNS解析顺序"><a href="#五、DNS解析顺序" class="headerlink" title="五、DNS解析顺序"></a>五、DNS解析顺序</h2><ol><li><strong>浏览器缓存</strong></li></ol><p>　　当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；</p><ol start="2"><li><strong>系统缓存</strong></li></ol><p>　　当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；</p><ol start="3"><li><strong>路由器缓存</strong></li></ol><p>　　当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；</p><ol start="4"><li><strong>ISP（互联网服务提供商）DNS缓存</strong></li></ol><p>　　当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；</p><ol start="5"><li><strong>根域名服务器</strong></li></ol><p>　　当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；</p><ol start="6"><li><strong>顶级域名服务器</strong></li></ol><p>　　顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；</p><ol start="7"><li><strong>主域名服务器</strong></li></ol><p>　　主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；</p><ol start="8"><li><strong>保存结果至缓存</strong></li></ol><p>　　本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/UDP详解</title>
      <link href="/posts/989d5490.html"/>
      <url>/posts/989d5490.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>你知道三次握手和四次挥手吗，能不能讲讲其中过程？为什么不能两次握手？还有为什么要四次挥手才断开连接呢？</p><h2 id="二、UDP连接"><a href="#二、UDP连接" class="headerlink" title="二、UDP连接"></a>二、UDP连接</h2><p>用户数据包协议（User Datagram Protocol），简称 UDP，是基于 IP 之上开发能和应用打交道的协议。</p><p>UDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。</p><p>通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。</p><p>UDP 传输缺陷：</p><ul><li>数据包在传输过程容易丢失</li><li>大文件传输中，UDP 并不知道如何组成这些数据包，不知道如何还原成完整的文件。</li></ul><p>虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。</p><h2 id="三、TCP-连接"><a href="#三、TCP-连接" class="headerlink" title="三、TCP 连接"></a>三、TCP 连接</h2><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>TCP 相对于 UDP 有 2 个特点：</p><ul><li>对于数据包的丢失，建立重传机制</li><li>TCP 引入数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件<br>在一个 TCP 连接中，会有 3 个过程。</li></ul><h3 id="3-1-建立连接阶段"><a href="#3-1-建立连接阶段" class="headerlink" title="3.1 建立连接阶段"></a>3.1 建立连接阶段</h3><p>这个阶段是通过 “三次握手” 来建立客户端和服务器之间的连接。</p><p>TCP 提供面向连接的通讯传输。面向连接是指数据通讯开始先做好两端之间的准备工作。</p><p>所谓 <strong>三次握手</strong> ，是指在建立一个 TCP 连接时，客户端和服务器总共要发送 3 个数据包来确认连接的建立。</p><p>三次握手主要作用是：</p><ul><li>确认双方的接收能力和发送能力</li><li>指定自己的初始化序列号，为后面的可靠性做准备</li></ul><h4 id="3-1-1-三次握手过程"><a href="#3-1-1-三次握手过程" class="headerlink" title="3.1.1 三次握手过程"></a>3.1.1 三次握手过程</h4><p>刚开始客户端处于 Closed 的状态，服务器处于 Listen 状态。</p><ol><li><p><strong>客户端发送到服务器。</strong>客户端发送 SYN 报文给服务器，并且指明客户端初始化序列号为 ISN(c)，即以 SYN=1, seq=x 的形式发送过去。此时客户端处于 SYN_SEND 状态。</p></li><li><p><strong>服务器发送给客户端。</strong>服务器收到客户端的 SYN 和 ISN(c)，也发送一个 SYN 回去，同时设置 ACK = ISN(c) + 1 以及指明服务器初始化序列号为 ISN(s)，即以 SYN=1, ACK=x+1， seq=y 的形式发送给客户端。 </p></li><li><p><strong>客户端发送到服务器。</strong>客户端收到服务器发送的消息后，设置 ACK = ISN(s) + 1，将自身的 ISN(c) + 1，即以 ACK=y+1, seq=x+1 的形式发送给服务器。此时客户端处于 ESTABLISHED 阶段，服务器收到报文，也处于 ESTABLISHED 阶段，双方建立了连接。</p></li></ol><h4 id="3-1-2-问题：两次握手不行吗？"><a href="#3-1-2-问题：两次握手不行吗？" class="headerlink" title="3.1.2 问题：两次握手不行吗？"></a>3.1.2 问题：两次握手不行吗？</h4><p>三次握手的目的：</p><ol><li>客户端发送数据给服务器，服务器确认自己可以接受客户端的请求。</li><li>服务器发送数据给客户端，客户端确认自己可以发送数据给服务器，也可以接受到服务器的请求。</li><li>客户端发送数据给服务器，服务器确认自己可以发送数据给客户端。</li></ol><p>如果采用两次握手，客户端发送数据给服务器，服务器确认后就当连接开始：</p><ol><li>客户端发送一次请求给服务器……指定时间后没响应再发了一个</li><li>服务器先接收到后一个建立连接的请求，然后前一个建立连接的请求，因为网络延迟等问题，在第二个之后达到了</li><li>服务器认为第二个请求是最新发的，于是向客户端发送确认报文段，同意建立连接，于是连接建立了（两次握手）</li><li>这时候客户端还在等待最新的请求连接（第二次请求），自动忽略服务器发送的关于第一个请求连接的响应，也不发送数据</li><li>服务器一直等待客户端发送数据，服务器资源被占用</li></ol><p>简单来说：</p><blockquote><p>客户端 -&gt; 1 -&gt; 服务器<br>客户端 -&gt; 2 -&gt; 服务器<br>服务器 get 1<br>服务器 get 2<br>服务器 reply 1<br>客户端 wait 2<br>gg</p></blockquote><p>所以才需要三次握手而不是两次握手。</p><h4 id="3-1-3-问题：三次握手过程中可以携带数据吗？"><a href="#3-1-3-问题：三次握手过程中可以携带数据吗？" class="headerlink" title="3.1.3 问题：三次握手过程中可以携带数据吗？"></a>3.1.3 问题：三次握手过程中可以携带数据吗？</h4><p>答案：第三次握手的时候可以携带，第一第二次不可以携带。</p><p>原因：如果第一次可以携带数据的话，有可能是恶意攻击服务器。这时候释放大量的数据，不理会服务器的的承受能力，让服务器花费很多时间、内存空间接收报文。</p><p>第三次握手的时候，客户端处于 ESTABLISHED 状态了，它可以建立连接并且知道服务器的接收、发送能力是正常的，所以可以携带数据了。</p><h3 id="3-2-传输数据阶段"><a href="#3-2-传输数据阶段" class="headerlink" title="3.2 传输数据阶段"></a>3.2 传输数据阶段</h3><p>此时客户端和服务器都处于 ESTABLISHED 状态。</p><p>这个阶段中，接收端需要对每个数据包进行确认操作。即接收端在接收到数据包之后，需要发送确认数据包给发送端。</p><p>如果发送端在规定时间内没有接收到接收端的反馈确认消息，那么判断丢包（数据包丢失），从而触发自身的重发机制。</p><p>一个大的文件在传输过程中会被拆分为多个小的数据包，接收端按照 TCP 头中的序号进行排序，保证组成完整的数据。</p><h3 id="3-3-断开连接阶段"><a href="#3-3-断开连接阶段" class="headerlink" title="3.3 断开连接阶段"></a>3.3 断开连接阶段</h3><p>数据传输完毕之后，需要终止连接，通过 四次挥手 来保证双方都能断开连接。</p><h4 id="3-3-1-四次挥手过程"><a href="#3-3-1-四次挥手过程" class="headerlink" title="3.3.1 四次挥手过程"></a>3.3.1 四次挥手过程</h4><ul><li><p><strong>客户端发送给服务器。</strong>客户端以 FIN=1, seq=u 的形式发送给服务器，表示需要关闭客户端和服务器的数据传输。此时客户端处于 FIN_WAIT 状态。</p></li><li><p><strong>服务器发送给客户端。</strong>服务器收到信息，先返回 ACK 给客户端，即以 ACK=1, seq=v, ack=u+1 的形式返回给客户端，表示收到客户端报文了。此时服务器处于 CLOST_WAIT 状态。</p></li><li><p><strong>服务器发送给客户端。</strong>服务器等待一会，看客户端还有没有数据没发过来，等处理完这些数据之后，也想断开连接了，于是发送 FIN 给客户端，即以 FIN=1, ACK=1, seq=w, ack=u+1 的形式发送给客户端。此时服务器处于 LAST_ACK 状态。</p></li><li><p><strong>客户端发送给服务器。</strong>客户端收到 FIN 之后，返回 ACK 报文作为应答，即以 ACK=1, seq=w+1 的形式发送给服务器。此时客户端处于 TIME_WAIT 状态。<br>过一阵子之后，客户端确保服务器收到自己的 ACK 报文了，则变成 CLOSED 状态。服务器接受到 ACK 报文之后，就也处于 CLOSED 状态了。</p></li></ul><h4 id="3-3-2-问题：为什么需要四次挥手"><a href="#3-3-2-问题：为什么需要四次挥手" class="headerlink" title="3.3.2 问题：为什么需要四次挥手"></a>3.3.2 问题：为什么需要四次挥手</h4><p>因为服务器接收到客户端的关闭请求之后。</p><p>如果有一些数据因为网络延迟等问题没有发送到，那么它直接关闭会导致这些数据没有接收到；亦或者服务器也有一些数据要发送给客户端，要确保这些数据发送完。</p><p>我们知道 TCP 是个可靠的棒小伙，所以它才会第一次回复客户端收到关闭连接的请求了，第二次回复客户端你发送的数据应该没延迟了，我也发送完我要发送的数据了，可以关闭了。</p><p>最后客户端接收到了，回复告诉服务器它也可以关闭了，然后过一阵子确保服务器接收到它发的 ACK 报文之后，也处于 CLOSED 状态了。</p><h2 id="四、TCP-和-UDP-的区别"><a href="#四、TCP-和-UDP-的区别" class="headerlink" title="四、TCP 和 UDP 的区别"></a>四、TCP 和 UDP 的区别</h2><ul><li>TCP 是面向连接的，UDP 是无连接的即发送数据前不需要先建立链接。</li><li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。并且因为 TCP 可靠，面向连接，不会丢失数据因此适合大数据量的交换。</li><li>TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。</li><li>TCP 只能是 1对1 的，UDP 支持 1对1，1对多。</li><li>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。</li><li>TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP/HTTPS详解</title>
      <link href="/posts/3562d4d4.html"/>
      <url>/posts/3562d4d4.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>HTTP 有时候面试官也会问到，简单的诸如 HTTP 状态码、GET 和 POST 区别。</p><p>这里会将 HTTP 相关知识点整理过来。</p><h2 id="二、HTTP发展史"><a href="#二、HTTP发展史" class="headerlink" title="二、HTTP发展史"></a>二、HTTP发展史</h2><h3 id="2-1-HTTP-0-9"><a href="#2-1-HTTP-0-9" class="headerlink" title="2.1 HTTP/0.9"></a>2.1 HTTP/0.9</h3><p>传输体积很小的文件，没有 HTTP 请求头和请求体，服务器也不返回头信息。</p><p>简述：</p><p>HTTP/0.9 并没有考虑太过复杂的内容，仅仅是用来传输体积很小的文件。</p><h3 id="2-2-HTTP-1-0"><a href="#2-2-HTTP-1-0" class="headerlink" title="2.2 HTTP/1.0"></a>2.2 HTTP/1.0</h3><p>核心诉求是支持多种类型的文件下载。加入了请求头和响应头支持多种不同类型的数据。以及状态码、Cache 机制、用户代理等。</p><p>简述：</p><p>应对 HTTP/0.9 出现的问题，进行了支持多类型文件下载等内容的优化。<br>HTTP/1.0 定义了三种请求方法：GET，POST 和 HEAD 方法。</p><h3 id="2-3-HTTP-1-1"><a href="#2-3-HTTP-1-1" class="headerlink" title="2.3 HTTP/1.1"></a>2.3 HTTP/1.1</h3><ol><li><p>改进了 HTTP/1.0 版本每次 HTTP 通信都需要建立 TCP 连接、传输 HTTP 数据再断开 TCP 连接的尴尬局面，支持持续连接。只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持（默认开启 keep-alive）。</p></li><li><p>如果 TCP 通道中某个请求因为某些原因没有及时返回，会阻塞后面所有请求（队头阻塞），所以 HTTP/1.1 通过管线化来解决队头阻塞的问题。</p></li><li><p>HTTP/1.0 每个域名绑定唯一 IP 地址，一个服务器只能支持一个域名。HTTP/1.1 请求头增加 Host 字段，表示当前域名地址，服务器可以根据不同的 Host 值做不同的处理。这样一台物理主机就可以绑定多个虚拟主机，每个虚拟主机都有自己单独的域名。 </p></li><li><p>HTTP/1.0 需要在响应头设置完整的数据大小来接收数据，但是随着服务器端发展，很多页面动态生成，不知道传输数据的最终大小。HTTP/1.1 引入 Chunk transfer 机制来解决这个问题，服务器将数据分割成任意大小的数据块，每个数据块发送时附带上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志，从而支持了动态内容。</p></li><li><p>客户端 Cookie、安全机制。</p></li></ol><p>简述：</p><ul><li>HTTP/1.1 默认开启 Connection: keep-alive，让一个 TCP 连接能重复发送/接收多次 HTTP 请求。</li><li>HTTP/1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</li></ul><h3 id="2-4-HTTP-2-0"><a href="#2-4-HTTP-2-0" class="headerlink" title="2.4 HTTP/2.0"></a>2.4 HTTP/2.0</h3><ol><li><p>一个域名只使用一个 TCP 长连接和消除队头阻塞问题 </p></li><li><p>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。HTTP/2.0 实现了一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</p></li><li><p>队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</p></li></ol><p>简述：</p><ul><li>头部压缩：HTTP/2 压缩消息头，减少了传输数据的大小</li><li>多路复用：即多个请求都通过一个 TCP 连接并发地完成</li><li>服务器推送：服务端能够主动把资源推送给客户端</li></ul><h3 id="2-5-HTTP-3-0"><a href="#2-5-HTTP-3-0" class="headerlink" title="2.5 HTTP/3.0"></a>2.5 HTTP/3.0</h3><p>简述：</p><ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。</li><li>集成了 TLS 加密功能。</li><li>实现了 HTTP/2 中的多路复用功能。</li><li>实现了快速握手功能。</li></ul><h2 id="三、HTTP"><a href="#三、HTTP" class="headerlink" title="三、HTTP"></a>三、HTTP</h2><p>Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器等一系列运作流程。而协议是指规则的约定。可以说，Web 是建立在 HTTP 协议上通信的。</p><p>HTTP 最初的目的是为了让研究者共享知识信息，所以它的主要作用就是文档传输，它是一种用于传输文档的协议。</p><h3 id="3-1-请求方法"><a href="#3-1-请求方法" class="headerlink" title="3.1 请求方法"></a>3.1 请求方法</h3><ul><li>GET：获取资源</li><li>HEAD：获取资源的元信息</li><li>POST：提交/上传 数据</li><li>PUT：修改数据</li><li>DELETE：删除资源（几乎用不到）</li><li>CONNECT：建立连接渠道，用于代理服务器</li><li>OPTIONS：列出可对资源实施的请求方法，用来跨域请求</li><li>TRACE：追踪请求-响应的传输路径</li></ul><h3 id="3-2-优缺点"><a href="#3-2-优缺点" class="headerlink" title="3.2 优缺点"></a>3.2 优缺点</h3><p>优点：</p><ol><li>灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</li><li>可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</li><li>请求-应答。也就是一发一收、有来有回，当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</li><li>无状态。这里的状态是指通信过程的上下文信息，而每次 HTTP 请求都是独立、无关的，默认不需要保留状态信息。</li></ol><p>缺点：</p><ol><li>无状态。在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 HTTP 的缺点了。</li><li>明文传输。协议里的报文（主要指的是头部）不使用二进制数据，而是文本形式。</li><li>队头阻塞问题。当 HTTP 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态。</li></ol><h3 id="3-3-GET-和-POST-的区别"><a href="#3-3-GET-和-POST-的区别" class="headerlink" title="3.3 GET 和 POST 的区别"></a>3.3 GET 和 POST 的区别</h3><p>GET 和 POST 方法没有实质区别，只是报文格式不同。</p><p>GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议。</p><p>无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。</p><ul><li>GET 获取资源；POST 提交/上传 数据。</li><li>GET 请求长度在浏览器中有限制，而 POST 并没有。</li><li>GET 请求会被浏览器主动保留下来（历史记录），而 POST 默认不会。</li></ul><h3 id="3-4-HTTP-和-TCP-区别"><a href="#3-4-HTTP-和-TCP-区别" class="headerlink" title="3.4 HTTP 和 TCP 区别"></a>3.4 HTTP 和 TCP 区别</h3><p>HTTP 是应用层协议，定义的是传输数据内容的规范；而 TCP 是底层通讯协议，定义的是数据传输和连接方式的规范。</p><p>HTTP 协议中的数据是利用 TCP 协议传输的，所以支持 HTTP 的也一定支持 TCP。</p><h2 id="四、HTTP状态码"><a href="#四、HTTP状态码" class="headerlink" title="四、HTTP状态码"></a>四、HTTP状态码</h2><p>HTTP 状态码为 3 位数，被归为 5 类：</p><ul><li>1XX：表示目前是协议处理的中间状态，还需要后续操作。</li><li>2XX：表示成功状态。</li><li>3XX：重定向状态，资源位置发生变动，需要重新请求。</li><li>4XX：请求报文有误。</li><li>5XX：服务器端发生错误。</li></ul><h3 id="4-1-1XX"><a href="#4-1-1XX" class="headerlink" title="4.1 1XX"></a>4.1 1XX</h3><ul><li>101 Switching Protocols：在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码为 101。</li></ul><h3 id="4-2-2XX"><a href="#4-2-2XX" class="headerlink" title="4.2 2XX"></a>4.2 2XX</h3><ul><li>200 OK：请求成功状态码，响应体中含有数据。</li><li>204 No Content：含义同 200，但是响应报文不含实体的主体部分。</li><li>206 Partial Content：表示部分内容请求成功。使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段 Content-Range。</li></ul><h3 id="4-3-3XX"><a href="#4-3-3XX" class="headerlink" title="4.3 3XX"></a>4.3 3XX</h3><ul><li>301 Move Permanently：永久重定向。HTTP 升级 HTTPS，之前站点再也不用，那就是 301。</li><li>302 Found：临时重定向。当前站点暂时不可用，那就是 302，后续可能换回来。</li><li>304 Not Modified：当命中协商缓存时会返回这个状态码。</li></ul><h3 id="4-4-4XX"><a href="#4-4-4XX" class="headerlink" title="4.4 4XX"></a>4.4 4XX</h3><ul><li>400 Bad Request：请求无效。通常为前后端数据格式不一致或者其他原因。</li><li>403 Forbidden：服务器已经得到请求，但是拒绝执行，比如没权限、法律禁止等。</li><li>404 Not Found：资源未找到，服务器不存在对应的资源。</li></ul><h3 id="4-5-5XX"><a href="#4-5-5XX" class="headerlink" title="4.5 5XX"></a>4.5 5XX</h3><ul><li>500 Internal Server Error：服务器报错，有些时候可以在 Response 看到后端 PHP 等技术的报错信息等。</li><li>502 Bad Gateway：服务器正常，但是访问出错。</li><li>503 Service Unavailable：服务器繁忙或者停机维护，暂时无法处理请求。</li></ul><h2 id="五、HTTPS"><a href="#五、HTTPS" class="headerlink" title="五、HTTPS"></a>五、HTTPS</h2><p>谈到 HTTPS, 就不得不谈到与之相对的 HTTP。</p><p>HTTP 的特性是明文传输，因此在传输的每一个环节，数据都有可能被第三方窃取或者篡改。</p><p>具体来说，HTTP 数据经过 TCP 层，然后经过 WIFI 路由器、运营商和目标服务器，这些环节中都可能被中间人拿到数据并进行篡改，也就是我们常说的中间人攻击。</p><p>为了防范这样一类攻击，我们不得已要引入新的加密方案，即 HTTPS。</p><p>简单来说 HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，比 HTTP 协议的安全性更高。</p><p>最后一个字母 S 指的是 SSL/TLS 协议，它位于 HTTP 协议与 TCP/IP 协议中间。</p><h3 id="5-1-工作原理"><a href="#5-1-工作原理" class="headerlink" title="5.1 工作原理"></a>5.1 工作原理</h3><ol><li>浏览器请求 URL，找到服务器，向服务器发送请求。服务器将自己的证书（包含服务器公钥）、对称加密算法种类以及其他相关信息返回给浏览器。</li><li>浏览器检查 CA 证书是否可依赖，确认证书有效。</li><li>如果不是，给服务器发警告，询问是否可以继续使用。</li><li>如果是，浏览器使用公钥加密一个随机对称秘钥，包含加密的 URL 一起发送给服务器。</li><li>服务器用自己的私钥解密浏览器发送的钥匙，然后用这把对称加密的钥匙给浏览器请求的 URL 连接解密。</li><li>服务器用浏览器发送的对称钥匙给请求的网页加密，浏览器使用相同的钥匙就可以解密网页。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/af5b5772afebc14ccf30e5b100da512722eecc88ec8309a40c9fc1f12c331ea1/68747470733a2f2f706963342e7a68696d672e636f6d2f38302f76322d31656130323039613532366633353237613731333733366665373630396663665f373230772e6a7067"></p><h3 id="5-2-优点"><a href="#5-2-优点" class="headerlink" title="5.2 优点"></a>5.2 优点</h3><ul><li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</li><li>HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li><li>谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称 “比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高”。 </li></ul><h3 id="5-3-缺点"><a href="#5-3-缺点" class="headerlink" title="5.3 缺点"></a>5.3 缺点</h3><ul><li>HTTPS 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20% 的耗电。</li><li>HTTPS 缓存不如 HTTP 高效，会增加数据开销。</li><li>SSL 证书也需要钱，功能越强大的证书费用越高。</li><li>SSL 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li></ul><h3 id="5-4-HTTP-和-HTTPS-对比"><a href="#5-4-HTTP-和-HTTPS-对比" class="headerlink" title="5.4 HTTP 和 HTTPS 对比"></a>5.4 HTTP 和 HTTPS 对比</h3><ul><li>概念对比。HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</li><li>费用对比。HTTPS 协议需要 CA 证书，费用较高。</li><li>连接方式和端口。使用不同的连接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li><li>安全性对比。HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ul><h2 id="六、HTTP-2"><a href="#六、HTTP-2" class="headerlink" title="六、HTTP/2"></a>六、HTTP/2</h2><p>由于 HTTPS 在安全方面已经做的非常好了，HTTP 改进的关注点放在了性能方面。对于 HTTP/2 而言，它对于性能的提升主要在于两点:</p><ul><li><p>头部压缩：HTTP/2 压缩消息头，减少了传输数据的大小</p></li><li><p>多路复用：即多个请求都通过一个 TCP 连接并发地完成<br>当然还有一些颠覆性的功能实现:</p></li><li><p>设置请求优先级</p></li><li><p>服务器推送：服务端能够主动把资源推送给客户端</p></li></ul><h3 id="6-1-头部压缩"><a href="#6-1-头部压缩" class="headerlink" title="6.1 头部压缩"></a>6.1 头部压缩</h3><p>在 HTTP/1.1 及之前的时代，请求体一般会有响应的压缩编码过程，通过 Content-Encoding 头部字段来指定。</p><p>但是，当请求字段非常复杂的时候，尤其对于 GET 请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的。</p><p>HTTP/2 针对头部字段，也采用了对应的压缩算法——HPACK，对请求头进行压缩。</p><h3 id="6-2-多路复用"><a href="#6-2-多路复用" class="headerlink" title="6.2 多路复用"></a>6.2 多路复用</h3><p>HTTP 队头阻塞的问题，其根本原因在于 HTTP 基于请求-响应的模型，在同一个 TCP 长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。</p><p>HTTP/2 便从 HTTP 协议本身解决了队头阻塞问题，即多个请求都通过一个 TCP 连接并发地完成。</p><h2 id="七、解决通讯安全问题"><a href="#七、解决通讯安全问题" class="headerlink" title="七、解决通讯安全问题"></a>七、解决通讯安全问题</h2><h3 id="7-1-对称加密"><a href="#7-1-对称加密" class="headerlink" title="7.1 对称加密"></a>7.1 对称加密</h3><p><strong>对称加密</strong> 可以理解为对原始数据的可逆变换。比如 Hello 可以变换成 Ifmmp，规则就是每个字母变成它在字母表上的后一个字母，这里的秘钥就是 1，另一方拿到 Ifmmp 就可以还原成原来的信息 Hello 了。</p><p>引入对称加密，HTTPS 握手流程多加两步：</p><ul><li>客户端：你好，我需要发起 HTTPS 请求</li><li>服务器：你好，你的秘钥是 1</li></ul><p>但是网络是不安全的啊，如果对称秘钥在发送的时候就被拦截了，发送的信息就可能被中间人窥视和篡改。</p><h3 id="7-2-非对称加密"><a href="#7-2-非对称加密" class="headerlink" title="7.2 非对称加密"></a>7.2 非对称加密</h3><p><strong>非对称加密</strong> 有两个秘钥：一个公钥、一个私钥。</p><blockquote><p>公钥和私钥成对出现，每个用户对应的那套公钥和私钥是不同的。</p></blockquote><p>服务器留着不对外公布的私钥，然后将公钥告诉所有人知道。</p><p>即公钥加密的内容只有私钥可以解密（服务器保留隐私），私钥加密的内容公钥可以解密（大众吃瓜权）。</p><ul><li>客户端：你好，我需要发起 HTTPS 请求</li><li>服务端：（生成公钥和私钥），你好，给你公钥 1</li><li>客户端：你好，经公钥加密后我要告诉你的信息是 XXX</li><li>服务端：通过私钥解密，得到数据 YYY。下次再发送数据的话还是私钥加密后再发送。</li><li>因为客户端和服务器使用的是两个不同的秘钥，所以这种算法叫做非对称加密。</li></ul><p>当然，结果还是容易被中间人攻击：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/a7a9f12edff208b0c31d03e57604a114ac82165021350734ec0e75ccc729a947/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f32312f313633383139376435366434366463373f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31"></p><blockquote><p>一般来说对称加密比非对称加密快，对服务器的运算压力小得多。</p></blockquote><h3 id="7-3-对称加密-非对称加密"><a href="#7-3-对称加密-非对称加密" class="headerlink" title="7.3 对称加密 + 非对称加密"></a>7.3 对称加密 + 非对称加密</h3><p>使用对称密钥的好处是解密的效率比较快，坏处是客户端的对称加密方法被知道了，服务端的也会被知道了。</p><p>而使用非对称密钥的好处是可以使得传输的内容不能被破解，但是坏处是非对称加密耗时比较多。</p><p>那我们就将对称加密与非对称加密结合起来，充分利用两者各自的优势。</p><p>在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。</p><ol><li>客户端：发送密文的一方使用对方的公钥进行加密处理，形成 “对称的秘钥”</li><li>服务端：用自己的私钥解密拿到 “对称的秘钥”，之后通讯用 “对称的秘钥” 进行加密，并发送给客户端</li><li>通讯过程：确保交换的密钥是安全的前提下，使用对称加密方式进行通信</li></ol><p>简单来说：</p><ol><li>服务器将公钥 key2 发送给客户端</li><li>客户端希望大家用 key3 作为对称秘钥，所以将包含 key3 的报文，用 key2 进行加密后，发送给服务器</li><li>服务器接收到到客户端加密后的报文，用私钥 key1 进行解密，得到 key3 的对称秘钥</li><li>后续双方都使用 key3 对发送/接收的报文进行加密/解密<br>HTTPS 就是采用这种对称加密和非对称加密两者并用的混合加密机制。</li></ol><p>但是，这种混合加密还是不能够保证数据的完整性和安全，在交换密钥的过程（数据稳定通讯之前）也是可能被替换的，所以要更加完美，还得需要数字签名（第三方认证）。</p><h3 id="7-4-第三方认证"><a href="#7-4-第三方认证" class="headerlink" title="7.4 第三方认证"></a>7.4 第三方认证</h3><p>公钥被掉包，是因为客户端无法分辨传回公钥的到底是中间人，还是服务器，这也是密码学中的身份验证问题。</p><p>在 HTTPS 中，为了解决无法验证公钥正确性的问题，使用数字证书认证机构（CA）及其颁发的数字证书来解决这个问题。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/c0decec731d432dab48914c6f864a9da4e4a39d5c58e747f33cfe024a6ae729c/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f32312f313633383139376439363137323961333f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31"></p><p>这里假设加密方式是 MD5，将网站的信息加密后通过第三方机构的私钥再次进行加密，生成数字签名。</p><blockquote><p>用 MD5 对网站信息进行加密，得到的内容叫消息摘要</p></blockquote><ul><li><strong>数字证书 = 网站信息 + 数字签名</strong></li></ul><p>假如中间人拦截后把服务器的公钥替换为自己的公钥，因为数字签名的存在，会导致客户端验证签名不匹配，这样就防止了中间人替换公钥的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/9c4b4d251a279253841dd971af1e691d4a8c5f6a8baea28fd1de29f856dfb2b9/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f32312f313633383139376436663430323835303f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31"></p><p>浏览器安装后会内置一些权威第三方认证机构的公钥，比如 VeriSign、Symantec 以及 GlobalSign 等等。</p><p>验证签名的时候直接就从本地拿到相应第三方机构的公钥，对私钥加密后的数字签名进行解密得到真正的签名，然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。</p><p>为了更加容易理解，最后的最后再进行梳理：</p><ol><li><p><strong>CA 业务流程：</strong>服务器向 CA 提出公钥认证的申请，申请注册自己的公钥。CA 在判明服务器的身份后，会对公钥做数字签名，然后用 CA 自己的私钥加密这份数字证书。<strong>数字证书 = 网站信息 + 数字签名</strong> </p></li><li><p><strong>客户端收到信息：</strong>服务器和客户端进行联系的时候，会将自身的证书和公钥传送给客户端。客户端使用 CA 的公钥，对证书进行解密，获取数字签名 A，然后根据 CA 的签名生成规则，进行签名生成，得到数字签名 B。进一步比对两者（A 和 B），如果不匹配，请求失败，否则成功。 </p></li><li><p><strong>客户端发送信息：</strong>这个环节跟混合加密（对称加密 + 非对称加密）的后续传输环节一致，即：客户端生成随机数，然后通过公钥进行加密，将加密后的数据发送给服务器，服务器通过私钥进行解密，然后双方用随机数对应的对称加密进行数据交流。</p></li><li><p><strong>保证安全：</strong>操作系统和浏览器会维护一个权威第三方认证机构的列表（包括他们的公钥）。<br>其实这个梳理包含了后面的 HTTPS 工作原理了，所以小伙伴顺着继续往下看吧~</p></li></ol><h3 id="7-5-第三方认证安全性"><a href="#7-5-第三方认证安全性" class="headerlink" title="7.5 第三方认证安全性"></a>7.5 第三方认证安全性</h3><ul><li>中间人可能篡改证书吗？</li></ul><p>假设中间人篡改了服务器发送给客户端的证书，由于他没有 CA 的私钥，所以无法得到加密后签名，无法篡改相应的签名。</p><p>浏览器收到这个证书后，使用 CA 的公钥，对证书进行解密，获取数字签名 A，然后根据 CA 的签名生成规则，进行签名生成，得到数字签名 B。进一步比对两者（A 和 B），如果不匹配，请求失败。</p><p>这样子就终止了向服务器传输信息。</p><ul><li>中间人可能将证书掉包吗？</li></ul><p>如果中间人设置另一个网站，也拿到了 CA 机构认证的证书，拦截了原本服务器的发送，将自己的证书发送给客户端，可以成功吗？</p><p>答案也是否的。因为证书中包含了原本服务器对应的网站信息（域名等），浏览器将证书中的域名和自己请求的域名比对一下，就知道有没有被掉包了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端实现Vue项目导出PDF</title>
      <link href="/posts/76d6af3f.html"/>
      <url>/posts/76d6af3f.html</url>
      
        <content type="html"><![CDATA[<h3 id="方式一：使用html2canvas和jspdf插件实现"><a href="#方式一：使用html2canvas和jspdf插件实现" class="headerlink" title="方式一：使用html2canvas和jspdf插件实现"></a>方式一：使用html2canvas和jspdf插件实现</h3><p>该方式是通过html2canvas将HTML页面转换成图片，然后再通过jspdf将图片的base64生成为pdf文件。</p><p>缺点：</p><ul><li>生成的pdf质量不高，失真比较严重；</li><li>在分页处如果有图片的话，不会自动识别隔页处理（甚至一行文字也能给你上下一分为二），而是无情地把图片一分为二。</li></ul><p>实现步骤如下：<br><strong>1.安装插件 ==jspdf html2canvas==</strong> </p><pre class="line-numbers language-js"><code class="language-js">    第一个<span class="token punctuation">.</span>将页面html转换成图片    npm install <span class="token operator">--</span>save html2canvas     第二个<span class="token punctuation">.</span>将图片生成pdf    npm install jspdf <span class="token operator">--</span>save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、创建htmlToPdf.js文件。(‘src/scripts/common/utils/htmlToPdf’)’</strong></p><p>分页处理：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> html2Canvas <span class="token keyword">from</span> <span class="token string">'html2canvas'</span><span class="token keyword">import</span> JsPDF <span class="token keyword">from</span> <span class="token string">'jspdf'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  install <span class="token punctuation">(</span>Vue<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getPdf <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>idStr<span class="token punctuation">,</span> title<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">html2Canvas</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#'</span> <span class="token operator">+</span> idStr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// allowTaint: true,</span>        useCORS<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// scale: 2, // 提升画面质量，但是会增加文件大小</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> contentWidth <span class="token operator">=</span> canvas<span class="token punctuation">.</span>width        <span class="token keyword">const</span> contentHeight <span class="token operator">=</span> canvas<span class="token punctuation">.</span>height        <span class="token comment" spellcheck="true">// 一页pdf显示html页面生成的canvas高度;</span>        <span class="token keyword">const</span> pageHeight <span class="token operator">=</span> contentWidth <span class="token operator">/</span> <span class="token number">592.28</span> <span class="token operator">*</span> <span class="token number">841.89</span>        <span class="token comment" spellcheck="true">// 生成pdf的html页面高度</span>        <span class="token keyword">let</span> leftHeight <span class="token operator">=</span> contentHeight        <span class="token comment" spellcheck="true">// 页面偏移</span>        <span class="token keyword">let</span> position <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true">// a4纸的尺寸[595.28,841.89]，html页面生成的canvas在pdf中图片的宽高</span>        <span class="token keyword">const</span> imgWidth <span class="token operator">=</span> <span class="token number">595.28</span>        <span class="token keyword">const</span> imgHeight <span class="token operator">=</span> <span class="token number">592.28</span> <span class="token operator">/</span> contentWidth <span class="token operator">*</span> contentHeight        <span class="token comment" spellcheck="true">// canvas.crossOrigin="anonymous";</span>        <span class="token keyword">const</span> pageData <span class="token operator">=</span> canvas<span class="token punctuation">.</span><span class="token function">toDataURL</span><span class="token punctuation">(</span><span class="token string">'image/jpeg'</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span>        <span class="token keyword">const</span> PDF <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsPDF</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'pt'</span><span class="token punctuation">,</span> <span class="token string">'a4'</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89)</span>        <span class="token comment" spellcheck="true">// 当内容未超过pdf一页显示的范围，无需分页</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftHeight <span class="token operator">&lt;</span> pageHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>          PDF<span class="token punctuation">.</span><span class="token function">addImage</span><span class="token punctuation">(</span>pageData<span class="token punctuation">,</span> <span class="token string">'JPEG'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> imgWidth<span class="token punctuation">,</span> imgHeight<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span>leftHeight <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            PDF<span class="token punctuation">.</span><span class="token function">addImage</span><span class="token punctuation">(</span>pageData<span class="token punctuation">,</span> <span class="token string">'JPEG'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> position<span class="token punctuation">,</span> imgWidth<span class="token punctuation">,</span> imgHeight<span class="token punctuation">)</span>            leftHeight <span class="token operator">-</span><span class="token operator">=</span> pageHeight            position <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">841.89</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>leftHeight <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 避免添加空白页</span>              PDF<span class="token punctuation">.</span><span class="token function">addPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>               PDF<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>title <span class="token operator">+</span> <span class="token string">'.pdf'</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不分页处理：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> html2Canvas <span class="token keyword">from</span> <span class="token string">'html2canvas'</span><span class="token keyword">import</span> JsPDF <span class="token keyword">from</span> <span class="token string">'jspdf'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  install <span class="token punctuation">(</span>Vue<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getPdf <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>idStr<span class="token punctuation">,</span> title<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">html2Canvas</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#'</span> <span class="token operator">+</span> idStr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// allowTaint: true,</span>        useCORS<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// scale: 2, // 提升画面质量，但是会增加文件大小</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> contentWidth <span class="token operator">=</span> canvas<span class="token punctuation">.</span>width        <span class="token keyword">const</span> contentHeight <span class="token operator">=</span> canvas<span class="token punctuation">.</span>height                  <span class="token comment" spellcheck="true">/* 导出不分页处理 */</span>        <span class="token keyword">const</span> pageData <span class="token operator">=</span> canvas<span class="token punctuation">.</span><span class="token function">toDataURL</span><span class="token punctuation">(</span><span class="token string">'image/jpeg'</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span>        <span class="token keyword">const</span> pdfWidth <span class="token operator">=</span> <span class="token punctuation">(</span>contentWidth <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">0.75</span>        <span class="token keyword">const</span> pdfHeight <span class="token operator">=</span> <span class="token punctuation">(</span>contentHeight <span class="token operator">+</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">0.75</span> <span class="token comment" spellcheck="true">// 500为底部留白</span>        <span class="token keyword">const</span> imgWidth <span class="token operator">=</span> pdfWidth        <span class="token keyword">const</span> imgHeight <span class="token operator">=</span> <span class="token punctuation">(</span>contentHeight <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">0.75</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 内容图片这里不需要留白的距离</span>        <span class="token keyword">const</span> PDF <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsPDF</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'pt'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> pdfWidth<span class="token punctuation">,</span> pdfHeight<span class="token punctuation">,</span> <span class="token punctuation">]</span><span class="token punctuation">)</span>        PDF<span class="token punctuation">.</span><span class="token function">addImage</span><span class="token punctuation">(</span>pageData<span class="token punctuation">,</span> <span class="token string">'jpeg'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> imgWidth<span class="token punctuation">,</span> imgHeight<span class="token punctuation">)</span>        PDF<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>title <span class="token operator">+</span> <span class="token string">'.pdf'</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3, 全局引入实现方法</strong><br>在项目主文件中引入定义好的实现方法，并注册</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> htmlToPdf <span class="token keyword">from</span> <span class="token string">'@/scripts/common/utils/htmlToPdf'</span><span class="token comment" spellcheck="true">// 使用Vue.use()方法就会调用工具方法中的install方法</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>htmlToPdf<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>4, 在相关要导出的页面中，点击时调用绑定在Vue原型上的getPdf方法，传入id即可</strong></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pdfDom<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    //给自己需要导出的ui部分.定义id为"pdfDom".此部分将就是pdf显示的部分<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>el-button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>export<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>导出PDF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>el-button</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            fileName<span class="token punctuation">:</span> <span class="token string">'页面导出PDF文件名'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    methods<span class="token punctuation">:</span><span class="token punctuation">{</span>        <span class="token keyword">export</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPdf</span><span class="token punctuation">(</span><span class="token string">'pdfDom'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fileName<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>问题：</strong></p><ul><li><p>分页：jspdf需要使用高度较小的图片，图片高度越小，分页效果就越好。</p></li><li><p>pdf清晰度：如果利用了echart之类，一定要用它给的api获取dataURL，设置分辨率倍数多一点，导出的图片非常清晰，这样生产的pdf才会清晰。如果是普通元素，如果发现导出的图片不够清晰，可以专门写一个用于导出的页面。此页面所有内容都放大2 倍，然后设置left:-9999隐藏（==不可display:none==）。当html2canvas转换此页面的为图片的时候，图片会非常大，然后使用pdf编辑工具让图片等比缩放，会很清晰。html2canvas option里也有个scale参数，也可以调，但太大会报错。</p></li></ul><h3 id="方式二：调用浏览器自身的方法。"><a href="#方式二：调用浏览器自身的方法。" class="headerlink" title="方式二：调用浏览器自身的方法。"></a>方式二：调用浏览器自身的方法。</h3><p>window.print() 来打印（打印时可选下载），打印比较清晰，但存在浏览器兼容问题，适用于谷歌。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端导出 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5的 input:file上传类型控制</title>
      <link href="/posts/c95caffd.html"/>
      <url>/posts/c95caffd.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、input-file属性"><a href="#一、input-file属性" class="headerlink" title="一、input:file属性"></a>一、input:file属性</h2><p>属性值有以下几个比较常用：</p><p>accept：表示可以选择的文件MIME类型，多个MIME类型用英文逗号分开，常用的MIME类型见下表。</p><p>multiple：是否可以选择多个文件，多个文件时其value值为第一个文件的虚拟路径。</p><h4 id="1、accept"><a href="#1、accept" class="headerlink" title="1、accept"></a>1、accept</h4><p>只能选择png和gif图片</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fileId1<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">accept</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>image/png,image/gif<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2、multiple"><a href="#2、multiple" class="headerlink" title="2、multiple"></a>2、multiple</h4><p>多文件上传</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fileId2<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">multiple</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>multiple<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3、常用MIME类型"><a href="#3、常用MIME类型" class="headerlink" title="3、常用MIME类型"></a>3、常用MIME类型</h4><table><thead><tr><th>后缀名</th><th>MIME名称</th></tr></thead><tbody><tr><td>*.3gpp</td><td>audio/3gpp, video/3gpp</td></tr><tr><td>*.ac3</td><td>audio/ac3</td></tr><tr><td>*.asf</td><td>allpication/vnd.ms-asf</td></tr><tr><td>*.au</td><td>audio/basic</td></tr><tr><td>*.css</td><td>text/css</td></tr><tr><td>*.csv</td><td>text/csv</td></tr><tr><td>*.doc</td><td>application/msword</td></tr><tr><td>*.dot</td><td>application/msword</td></tr><tr><td>*.dtd</td><td>application/xml-dtd</td></tr><tr><td>*.dwg</td><td>image/vnd.dwg</td></tr><tr><td>*.dxf</td><td>image/vnd.dxf</td></tr><tr><td>*.gif</td><td>image/gif</td></tr><tr><td>*.htm</td><td>text/html</td></tr><tr><td>*.html</td><td>text/html</td></tr><tr><td>*.jp2</td><td>image/jp2</td></tr><tr><td>*.jpe</td><td>image/jpeg</td></tr><tr><td>*.jpeg</td><td>image/jpeg</td></tr><tr><td>*.jpg</td><td>image/jpeg</td></tr><tr><td>*.js</td><td>text/javascript, application/javascript</td></tr><tr><td>*.json</td><td>application/json</td></tr><tr><td>*.mp2</td><td>audio/mpeg, video/mpeg</td></tr><tr><td>*.mp3</td><td>audio/mpeg</td></tr><tr><td>*.mp4</td><td>audio/mp4, video/mp4</td></tr><tr><td>*.mpeg</td><td>video/mpeg</td></tr><tr><td>*.mpg</td><td>video/mpeg</td></tr><tr><td>*.mpp</td><td>application/vnd.ms-project</td></tr><tr><td>*.ogg</td><td>application/ogg, audio/ogg</td></tr><tr><td>*.pdf</td><td>application/pdf</td></tr><tr><td>*.png</td><td>image/png</td></tr><tr><td>*.pot</td><td>application/vnd.ms-powerpoint</td></tr><tr><td>*.pps</td><td>application/vnd.ms-powerpoint</td></tr><tr><td>*.ppt</td><td>application/vnd.ms-powerpoint</td></tr><tr><td>*.rtf</td><td>application/rtf, text/rtf</td></tr><tr><td>*.svf</td><td>image/vnd.svf</td></tr><tr><td>*.tif</td><td>image/tiff</td></tr><tr><td>*.tiff</td><td>image/tiff</td></tr><tr><td>*.txt</td><td>text/plain</td></tr><tr><td>*.wdb</td><td>application/vnd.ms-works</td></tr><tr><td>*.wps</td><td>application/vnd.ms-works</td></tr><tr><td>*.xhtml</td><td>application/xhtml+xml</td></tr><tr><td>*.xlc</td><td>application/vnd.ms-excel</td></tr><tr><td>*.xlm</td><td>application/vnd.ms-excel</td></tr><tr><td>*.xls</td><td>application/vnd.ms-excel</td></tr><tr><td>*.xlt</td><td>application/vnd.ms-excel</td></tr><tr><td>*.xlw</td><td>application/vnd.ms-excel</td></tr><tr><td>*.xml</td><td>text/xml, application/xml</td></tr><tr><td>*.zip</td><td>aplication/zip</td></tr><tr><td>*.xlsx</td><td>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</td></tr></tbody></table><h2 id="二、样式美化"><a href="#二、样式美化" class="headerlink" title="二、样式美化"></a>二、样式美化</h2><p>请看博客： <a href="http://www.haorooms.com/post/css_input_uploadmh">css input[type=file] 样式美化，input上传按钮美化</a></p><h2 id="三、AJAX上传文件"><a href="#三、AJAX上传文件" class="headerlink" title="三、AJAX上传文件"></a>三、AJAX上传文件</h2><p>在说到ajax上传文件。ajax上传的时候，需要获得input:file选择的文件（可能为多个文件），获取其文件列表为：</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token comment" spellcheck="true">// input标签的files属性</span>    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#fileId"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>files    <span class="token comment" spellcheck="true">// 返回的是一个文件列表数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>获得的文件列表，然后遍历插入到表单数据当中。即：</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token comment" spellcheck="true">// 获得上传文件DOM对象</span>    <span class="token keyword">var</span> oFiles <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#fileId"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 实例化一个表单数据对象</span>    <span class="token keyword">var</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历图片文件列表，插入到表单数据中</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> file<span class="token punctuation">;</span> file <span class="token operator">=</span> oFiles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 文件名称，文件对象</span>        formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span>name<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获得表单数据之后，就可以用ajax的POST上传。</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token comment" spellcheck="true">// 实例化一个AJAX对象</span>    <span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    xhr<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"上传成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">,</span> <span class="token string">"upload.php"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 发送表单数据</span>    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>formData<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上传到服务器之后，获取到文件列表为：</p><pre class="line-numbers language-js"><code class="language-js">    Array    <span class="token punctuation">(</span>        <span class="token punctuation">[</span>jpg_jpg<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> Array            <span class="token punctuation">(</span>                <span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> jpg<span class="token punctuation">.</span>jpg                <span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> image<span class="token operator">/</span>jpeg                <span class="token punctuation">[</span>tmp_name<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> D<span class="token punctuation">:</span>\xampp\tmp\phpA595<span class="token punctuation">.</span>tmp                <span class="token punctuation">[</span>error<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">0</span>                <span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">133363</span>            <span class="token punctuation">)</span>            <span class="token punctuation">[</span>png_png<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> Array            <span class="token punctuation">(</span>                <span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> png<span class="token punctuation">.</span>png                <span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> image<span class="token operator">/</span>png                <span class="token punctuation">[</span>tmp_name<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> D<span class="token punctuation">:</span>\xampp\tmp\phpA5A6<span class="token punctuation">.</span>tmp                <span class="token punctuation">[</span>error<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">0</span>                <span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">1214628</span>            <span class="token punctuation">)</span>        <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在服务端循环遍历这个数组就可以上传文件了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 Blob 实现文件下载功能</title>
      <link href="/posts/b07c11d1.html"/>
      <url>/posts/b07c11d1.html</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理其实很简单，就是将文本或者JS字符串信息（即后台返回来的在服务器上没有具体路径的动态文件，如导出数据功能）借助Blob转换成二进制，然后，作为 a 标签的 href 属性，配合download属性，实现下载功能，缺点是如果文件太大会下载失败。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面是导出数据的一个实例：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#exportAll"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//点击【全部导出】</span>    <span class="token comment" spellcheck="true">//layer.load();</span>    <span class="token keyword">var</span> province <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#operatingData select[name=\'province\'] option:selected'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//查询条件（省）</span>    <span class="token keyword">var</span> city <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#operatingData select[name=\'city\'] option:selected'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//查询条件（市）</span>    <span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">'/xxx/excelAllDownload'</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//【全部导出】请求url</span>    <span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span><span class="token string">"application/x-www-form-urlencoded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    xhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">"blob"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//返回类型blob</span>    xhr<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//定义请求完成的处理函数</span>        <span class="token comment" spellcheck="true">//layer.closeAll('loading');</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> blob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token punctuation">;</span>            <span class="token keyword">var</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            reader<span class="token punctuation">.</span><span class="token function">readAsDataURL</span><span class="token punctuation">(</span>blob<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 转换为base64，可以直接放入a标签href</span>            reader<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">var</span> a <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 转换完成，创建一个a标签用于下载</span>                a<span class="token punctuation">.</span>download <span class="token operator">=</span> <span class="token string">'XX数据.xlsx'</span><span class="token punctuation">;</span>                a<span class="token punctuation">.</span>href <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>result<span class="token punctuation">;</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 修复firefox中无法触发click</span>                a<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">$</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">504</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'导出失败，请求超时'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//layer.msg('导出失败，请求超时', {icon: 2});</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'导出失败'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//layer.msg('导出失败', {icon: 2});</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"province="</span> <span class="token operator">+</span> province <span class="token operator">+</span> <span class="token string">"&amp;city="</span> <span class="token operator">+</span> city<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>上面是在服务器动态生成excel文件时使用的下载方式，因为对应的 URL 并不存在，我们就不能简单的指定 href 属性。</p><p>但是不同浏览器对 Blob （类文件对象）有不同的大小限制，这种借助Blob转换成二进制 实现下载功能的方式并不能导出数据量过多的数据到excel文件（即不能下载太大的文件），且有兼容性问题。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://img-blog.csdnimg.cn/2019062516033645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTY4NjA5,size_16,color_FFFFFF,t_70" alt="不同浏览器对 Blob 的限制"></p><p>所以，我们可以通过 JavaScript 对服务器发出一个请求，通知它去生成某个文件，然后把对应的 URL 返回给客户端。代码如下：（此时的请求结果为一个已经存在于服务器上面的静态文件的路径）</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#exportAll"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//点击【全部导出】</span>    <span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">'/xxx/excelAllDownload'</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//【全部导出】请求url</span>    <span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span><span class="token string">"application/x-www-form-urlencoded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    xhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">"blob"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//返回类型blob</span>    xhr<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//定义请求完成的处理函数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//方式一实现静态文件下载，不能自定义下载文件名字</span>            <span class="token comment" spellcheck="true">//location.href = "json/abc.xlsx";  //this.response（返回的服务器上的静态文件路径）</span>            <span class="token comment" spellcheck="true">//方式二实现静态文件下载，可以自定义下载文件名字</span>            <span class="token keyword">var</span> a <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建a标签用于下载</span>            a<span class="token punctuation">.</span>download <span class="token operator">=</span> <span class="token string">'XXX数据.xlsx'</span><span class="token punctuation">;</span>            a<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">"json/abc.xlsx"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//this.response（返回的服务器上的静态文件路径）</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 修复firefox中无法触发click</span>            a<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">$</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">504</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'导出失败，请求超时'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'导出失败'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 文件下载 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端下载文件方法总结</title>
      <link href="/posts/e979ee3f.html"/>
      <url>/posts/e979ee3f.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-链接下载文件"><a href="#1-链接下载文件" class="headerlink" title="1.  链接下载文件"></a>1.  链接下载文件</h4><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">//该方法火狐有些版本是不支持的</span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href<span class="token operator">=</span>url <span class="token comment" spellcheck="true">//为了解决火狐有些版本不支持,可以改成这种方式</span>window<span class="token punctuation">.</span>location<span class="token operator">=</span>url <span class="token comment" spellcheck="true">//该方法在火狐上没有效果的，在IE浏览器上是可以的</span>window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token string">'_blank'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 打开新窗口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>优点: 兼容性良好，代码简洁；</li><li>缺点: <ul><li>URL长度有限制；</li><li>拿不到后端处理这个过程的时机，无法根据回调函数做交互以及进度提示</li></ul></li></ul><h4 id="2-iframe-下载文件"><a href="#2-iframe-下载文件" class="headerlink" title="2.   iframe 下载文件"></a>2.   iframe 下载文件</h4><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> elemIF <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span>    elemIF<span class="token punctuation">.</span>src <span class="token operator">=</span> url <span class="token comment" spellcheck="true">//url为后端返回路径</span>    elemIF<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>elemIF<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 防止下载两次</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>elemIF<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>优点: 兼容性良好，代码简洁；</li><li>缺点: <ul><li> URL长度有限制；</li><li> 拿不到后端处理这个过程的时机，无法根据回调函数做交互以及进度提示；</li><li>URL长度有限制；</li></ul></li></ul><h4 id="3-HTML5-新增download属性"><a href="#3-HTML5-新增download属性" class="headerlink" title="3.  HTML5  新增download属性"></a>3.  HTML5  新增download属性</h4><p>这个属性很重要，它可以指定下载文件名，并且可以告诉浏览器目标链接是一个下载链接，不是一个普通链接，我们看下面代码就能看出区别了：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>data:text/txt;charset<span class="token punctuation">=</span>utf-8,测试下载纯文本<span class="token punctuation">"</span></span> <span class="token attr-name">download</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>测试.txt<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>下载1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>data:text/txt;charset<span class="token punctuation">=</span>utf-8,测试下载纯文本<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>下载2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以发现，下载1按钮能够实现下载，点击下载2链接时直接在浏览器打开文件内容了。</p><p>==补充说明：==</p><blockquote><p>file:///模式下貌似不生效；<br> 链接指向一些第三方链接时也不会生效，具体有待研究；</p></blockquote><h4 id="4-后端返回Blob对象"><a href="#4-后端返回Blob对象" class="headerlink" title="4.  后端返回Blob对象"></a>4.  后端返回Blob对象</h4><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">download</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> filename<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 字符内容转变成blob地址</span>    <span class="token keyword">var</span> blob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>content<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">'msSaveOrOpenBlob'</span> <span class="token keyword">in</span> navigator<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//兼容IE</span>        window<span class="token punctuation">.</span>navigator<span class="token punctuation">.</span><span class="token function">msSaveOrOpenBlob</span><span class="token punctuation">(</span>blob<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> eleLink <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    eleLink<span class="token punctuation">.</span>download <span class="token operator">=</span> filename<span class="token punctuation">;</span>    <span class="token function">$</span><span class="token punctuation">(</span>eleLink<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'display'</span><span class="token punctuation">,</span> <span class="token string">'none'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    eleLink<span class="token punctuation">.</span>href <span class="token operator">=</span> URL<span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>blob<span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>eleLink<span class="token punctuation">)</span><span class="token punctuation">;</span>    eleLink<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>eleLink<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-axios（ajax）前端根据返回数据流生成文件下载"><a href="#5-axios（ajax）前端根据返回数据流生成文件下载" class="headerlink" title="5.  axios（ajax）前端根据返回数据流生成文件下载"></a>5.  axios（ajax）前端根据返回数据流生成文件下载</h4><pre class="line-numbers language-js"><code class="language-js">axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> param<span class="token punctuation">,</span> <span class="token punctuation">{</span>  responseType<span class="token punctuation">:</span> <span class="token string">'blob'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'res'</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> blob <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">;</span>  <span class="token keyword">const</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  reader<span class="token punctuation">.</span><span class="token function">readAsDataURL</span><span class="token punctuation">(</span>blob<span class="token punctuation">)</span><span class="token punctuation">;</span>  reader<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> a <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>download <span class="token operator">=</span> <span class="token template-string"><span class="token string">`文件名称.zip`</span></span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 后端设置的文件名称在res.headers的 "content-disposition": "form-data; name=\"attachment\"; filename=\"20181211191944.zip\"",</span>    a<span class="token punctuation">.</span>href <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>result<span class="token punctuation">;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 文件下载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github博客搭建教程</title>
      <link href="/posts/95771693.html"/>
      <url>/posts/95771693.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo-简介"><a href="#Hexo-简介" class="headerlink" title="Hexo 简介"></a>Hexo 简介</h2><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入<a href="https://hexo.io/zh-cn/">hexo官网</a>进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><p>教程分三个部分，</p><p>第一部分：hexo的初级搭建还有部署到github page上，以及个人域名的绑定。<br>第二部分：hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流<br>第三部分：hexo添加各种功能，包括搜索的SEO，阅读量统计，访问量统计和评论系统等。</p><h2 id="Hexo搭建步骤"><a href="#Hexo搭建步骤" class="headerlink" title="Hexo搭建步骤"></a>Hexo搭建步骤</h2><p>1.安装Git<br>2.安装Node.js<br>3.安装Hexo<br>4.GitHub创建个人仓库<br>5.生成SSH添加到GitHub<br>6.将hexo部署到GitHub</p><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h3><p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，具体的安装教程参见另一篇博客<a href="https://blog.csdn.net/qq_42968609/article/details/111491388?spm=1001.2014.3001.5501">Git教程</a></p><p>windows：到git官网上下载,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</p><p>linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码</p><pre class="line-numbers language-js"><code class="language-js">sudo apt<span class="token operator">-</span><span class="token keyword">get</span> install git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装好后，用git –version 来查看一下版本</p><h3 id="2-安装nodejs"><a href="#2-安装nodejs" class="headerlink" title="2.安装nodejs"></a>2.安装nodejs</h3><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</p><p>windows：<a href="https://nodejs.org/en/download/">nodejs</a>选择LTS版本就行了。</p><p>linux：</p><pre class="line-numbers language-js"><code class="language-js">sudo apt<span class="token operator">-</span><span class="token keyword">get</span> install nodejssudo apt<span class="token operator">-</span><span class="token keyword">get</span> install npm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装完后，打开命令行</p><pre class="line-numbers language-js"><code class="language-js">node <span class="token operator">-</span>vnpm <span class="token operator">-</span>v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>检查一下有没有安装成功</p><p>顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。</p><h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h3><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>输入命令</p><pre class="line-numbers language-js"><code class="language-js">npm install <span class="token operator">-</span>g hexo<span class="token operator">-</span>cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>依旧用hexo -v查看一下版本</p><p>至此就全部安装完了。</p><p>接下来初始化一下hexo</p><pre class="line-numbers language-js"><code class="language-js">hexo init myblog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个myblog可以自己取什么名字都行，然后</p><pre class="line-numbers language-js"><code class="language-js">cd myblog <span class="token comment" spellcheck="true">//进入这个myblog文件夹</span>npm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>** _config.yml: 博客的配置文件**</li></ul><p>打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。<br>使用ctrl+c可以把服务关掉。</p><h3 id="4-GitHub创建个人仓库"><a href="#4-GitHub创建个人仓库" class="headerlink" title="4.GitHub创建个人仓库"></a>4.GitHub创建个人仓库</h3><p>首先，你先要有一个GitHub账户，去注册一个吧。</p><p>注册完登录后，在GitHub.com中看到一个New repository，新建仓库</p><p>创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。</p><p>点击create repository。</p><h3 id="5-生成SSH添加到GitHub"><a href="#5-生成SSH添加到GitHub" class="headerlink" title="5.生成SSH添加到GitHub"></a>5.生成SSH添加到GitHub</h3><p>回到你的git bash中，</p><pre class="line-numbers language-js"><code class="language-js">git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"yourname"</span>git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。</p><p>可以用以下两条，检查一下你有没有输对</p><pre class="line-numbers language-js"><code class="language-js">git config user<span class="token punctuation">.</span>namegit config user<span class="token punctuation">.</span>email<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后创建SSH,一路回车</p><pre class="line-numbers language-js"><code class="language-js">ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa <span class="token operator">-</span>C <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。</p><p>ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p><p>而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key<br>把你的id_rsa.pub里面的信息复制进去。</p><h3 id="6-将hexo部署到GitHub"><a href="#6-将hexo部署到GitHub" class="headerlink" title="6.将hexo部署到GitHub"></a>6.将hexo部署到GitHub</h3><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户 </p><pre class="line-numbers language-js"><code class="language-js">deploy<span class="token punctuation">:</span>  type<span class="token punctuation">:</span> git  repo<span class="token punctuation">:</span> https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>YourgithubName<span class="token operator">/</span>YourgithubName<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io<span class="token punctuation">.</span>git  branch<span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><pre class="line-numbers language-js"><code class="language-js">npm install hexo<span class="token operator">-</span>deployer<span class="token operator">-</span>git <span class="token operator">--</span>save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后</p><pre class="line-numbers language-js"><code class="language-js">hexo cleanhexo generatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中 hexo clean清除了你之前生成的东西，也可以不加。<br>hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写</p><p>注意deploy时可能要你输入username和password。</p><p>部署成功后就可以在<a href="http://yourname.github.io/">http://yourname.github.io</a> 这个网站看到你的博客了！！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
